{"meta":{"title":"Escher","subtitle":"","description":"This is Escher's Blog","author":"Escher","url":"http://liujun1997.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-10-26T13:58:35.286Z","updated":"2021-08-06T14:45:53.000Z","comments":false,"path":"/404.html","permalink":"http://liujun1997.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-10-26T13:58:35.282Z","updated":"2021-08-07T05:40:25.000Z","comments":false,"path":"about/index.html","permalink":"http://liujun1997.github.io/about/index.html","excerpt":"","text":"二线城市苦逼搬砖码农"},{"title":"书单","date":"2021-10-26T13:58:35.282Z","updated":"2021-08-06T14:46:44.000Z","comments":false,"path":"books/index.html","permalink":"http://liujun1997.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-10-26T13:58:35.287Z","updated":"2021-08-06T14:46:02.000Z","comments":false,"path":"categories/index.html","permalink":"http://liujun1997.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-10-26T13:58:35.285Z","updated":"2021-08-06T14:46:15.000Z","comments":true,"path":"links/index.html","permalink":"http://liujun1997.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-10-26T13:58:35.261Z","updated":"2021-08-06T14:46:08.000Z","comments":false,"path":"repository/index.html","permalink":"http://liujun1997.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-10-26T13:58:35.284Z","updated":"2021-08-06T14:46:51.000Z","comments":false,"path":"tags/index.html","permalink":"http://liujun1997.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mysql常用函数","slug":"Mysql函数","date":"2021-12-15T13:19:57.000Z","updated":"2021-12-15T13:21:37.161Z","comments":true,"path":"2021/12/15/Mysql函数/","link":"","permalink":"http://liujun1997.github.io/2021/12/15/Mysql%E5%87%BD%E6%95%B0/","excerpt":"","text":"mysql 常用函数1.字符串函数 函数 含义 lower 字符串转为小写 upper 字符串转为大写 concat 字符串连接 concat_ws 将多个字符串按指定字符连接 substr(str,pos,len) 将字符串按下标分割，下标从0开始 length 返回字符串的存储长度 char_length 返回字符串的字符个数 instr(str,substr) 返回指定字符串substr 在str字符串第一出现的位置 lpad(str,legth,padstr) 在源字符str左(右边)边填充padstr到指定长度length TRIM([{BOTH | LEADING | TRAILING} [remstr] FROM] str), TRIM([remstr FROM] str) 从源字符str中去除两端，左前缀，右后缀的remstr字符 REPLACE(str, from_str, to_str) 源字符串str中查找所有的子串form_str（大小写敏感），找到后使用替代字符串to_str替换它 LTRIM(str)，RTRIM(str) 去掉字符串的左边或右边的空格(左对齐、右对齐) REPEAT(str, count) 将字符串str重复count次后返回 REVERSE(str) 将字符串str反转后返回 FORMAT(X,D[,locale]) 格式化数字X，D指定小数位数，locale指定国家语言(默认的locale为en_US) LEFT(str, len)，RIGHT(str, len) 返回最左(右)边的len长度的子串 STRCMP(expr1,expr2) 如果两个字符串是一样的则返回0；如果第一个小于第二个则返回-1；否则返回1 || 管道连接符 select 列名1 || 列名2 || 列名3 from 表名; 进行上式连接查询之后，会将查询结果集在一列中显示(字符串连接)，列名是‘列名1 || 列名2 || 列名3’； 2.日期时间函数 now() 返回当前日期时间 12345678mysql&gt; select now();+---------------------+| now() |+---------------------+| 2021-12-01 10:56:05 |+---------------------+1 row in set (0.00 sec) curdate() 返回当前日期 1234567mysql&gt; select curdate();+------------+| curdate() |+------------+| 2021-12-01 |+------------+1 row in set (0.00 sec) curtime() 1234567mysql&gt; select curtime();+-----------+| curtime() |+-----------+| 11:04:07 |+-----------+1 row in set (0.00 sec) date(date) 提取指定字段的日期 12345678mysql&gt; select date(now());+-------------+| date(now()) |+-------------+| 2021-12-01 |+-------------+1 row in set (0.00 sec) extract(unit from 字段名) 提取日期/时间表达中指定时间单位 unit 单位表 Unit 值 MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUARTER YEAR SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR YEAR_MONTH 123456789101112131415161718192021mysql&gt; select extract(year from now()) as year -&gt; ,extract(month from now()) as month, -&gt; extract(day from now()) as day, -&gt; extract(hour from now()) as hour, -&gt; extract(minute from now()) as minute, -&gt; extract(second from now()) as seconde, -&gt; extract(microsecond from now()) as microsecond;+------+-------+------+------+--------+---------+-------------+| year | month | day | hour | minute | seconde | microsecond |+------+-------+------+------+--------+---------+-------------+| 2021 | 12 | 1 | 11 | 13 | 40 | 0 |+------+-------+------+------+--------+---------+-------------+1 row in set (0.00 sec)mysql&gt; select extract(day from &#x27;2021-10-02&#x27;);+--------------------------------+| extract(day from &#x27;2021-10-02&#x27;) |+--------------------------------+| 2 |+--------------------------------+1 row in set (0.00 sec) date_add/sub() 给指定日期/时间表达式加(减)上指定时间间隔 12345678910111213141516mysql&gt; select date_add(now(),interval 1 day);+--------------------------------+| date_add(now(),interval 1 day) |+--------------------------------+| 2021-12-02 11:21:41 |+--------------------------------+1 row in set (0.00 sec)----------------------------------------------mysql&gt; select date_sub(now(),interval 1 day);+--------------------------------+| date_sub(now(),interval 1 day) |+--------------------------------+| 2021-11-30 11:21:58 |+--------------------------------+1 row in set (0.00 sec) Date_Format(date,format) 将日期按指定的日期/时间格式输出 mysql时间格式 格式 描述 %a 缩写星期名 %b 缩写月名 %c 月，数值 %D 带有英文前缀的月中的天 %d 月的天，数值（00-31） %e 月的天，数值（0-31） %f 微秒 %H 小时（00-23） %h 小时（01-12） %I 小时（01-12） %i 分钟，数值（00-59） %j 年的天（001-366） %k 小时（0-23） %l 小时（1-12） %M 月名 %m 月，数值（00-12） %p AM 或 PM %r 时间，12-小时（hh:mm:ss AM 或 PM） %S 秒（00-59） %s 秒（00-59） %T 时间, 24-小时（hh:mm:ss） %U 周（00-53）星期日是一周的第一天 %u 周（00-53）星期一是一周的第一天 %V 周（01-53）星期日是一周的第一天，与 %X 使用 %v 周（01-53）星期一是一周的第一天，与 %x 使用 %W 星期名 %w 周的天（0=星期日, 6=星期六） %X 年，其中的星期日是周的第一天，4 位，与 %V 使用 %x 年，其中的星期一是周的第一天，4 位，与 %v 使用 %Y 年，4 位 %y 年，2 位 1234567mysql&gt; select date_format(now(),&#x27;%Y%m%d %H%i%S&#x27;);+------------------------------------+| date_format(now(),&#x27;%Y%m%d %H%i%S&#x27;) |+------------------------------------+| 20211201 113323 |+------------------------------------+1 row in set (0.00 sec) unix_timestamp(date) 日期/时间表达式转时间戳 1234567mysql&gt; select unix_timestamp(&#x27;2021-10-11 10:12:12&#x27;);+---------------------------------------+| unix_timestamp(&#x27;2021-10-11 10:12:12&#x27;) |+---------------------------------------+| 1633918332 |+---------------------------------------+1 row in set (0.00 sec) str_to_date(date) 字符串转日期 1234567mysql&gt; select str_to_date(&#x27;2021-10-11 10:12:12&#x27;,&#x27;%Y-%m-%d %H:%i:%S&#x27;);+--------------------------------------------------------+| str_to_date(&#x27;2021-10-11 10:12:12&#x27;,&#x27;%Y-%m-%d %H:%i:%S&#x27;) |+--------------------------------------------------------+| 2021-10-11 10:12:12 |+--------------------------------------------------------+1 row in set (0.00 sec) from_unitime(timestamp,{format}) 时间戳转字符串/日期 12345678mysql&gt; select from_unixtime(1509257408,&#x27;%Y~%m~%d %H:%i:%S&#x27;);+-----------------------------------------------+| from_unixtime(1509257408,&#x27;%Y~%m~%d %H:%i:%S&#x27;) |+-----------------------------------------------+| 2017~10~29 14:10:08 |+-----------------------------------------------+1 row in set (0.00 sec)","categories":[{"name":"数据库","slug":"数据库","permalink":"http://liujun1997.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://liujun1997.github.io/tags/mysql/"}]},{"title":"Centos7-Mysql5.7安装","slug":"Centos7-Mysql5-7安装","date":"2021-10-13T07:59:26.000Z","updated":"2021-10-13T11:59:54.000Z","comments":true,"path":"2021/10/13/Centos7-Mysql5-7安装/","link":"","permalink":"http://liujun1997.github.io/2021/10/13/Centos7-Mysql5-7%E5%AE%89%E8%A3%85/","excerpt":"","text":"环境准备 Centos 7系统, x86架构 1234[root@CentOS7-2 ~]# uname -sLinux[root@CentOS7-2 ~]# uname -mx86_64 centos镜像源中没有mysql镜像源，需要下载mysql镜像源，执行完成后会在/etc/yum.repos.d/目录下生成两个repo文件mysql-community.repo mysql-community-source.repo 123[root@CentOS7-2 ~]# wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm[root@CentOS7-2 ~]# rpm -ivh mysql57-community-release-el7-9.noarch.rpm 安装mysql-5.7 1[root@CentOS7-2 ~]# yum install mysql-server -y 启动mysql 1[root@CentOS7-2 ~]# systemctl start mysqld 获取临时密码登录mysql 1234567891011121314151617[root@CentOS7-2 ~]# grep &#x27;temporary password&#x27; /var/log/mysqld.log2021-10-13T06:59:08.797851Z 1 [Note] A temporary password is generated for root@localhost: wZvCfS)LI0kf # (mysql安装临时密码) 如果没有临时密码， 删除原来安装过的mysql残留的数据 rm -rf /var/lib/mysql[root@CentOS7-2 ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.7.35Copyright (c) 2000, 2021, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.mysql&gt; 如果登录不了，需要修改配置文件跳过密码登录 vim /etc/my.cnf 在mysqld域增加一行skip-grant-tables 12345678910111213141516171819202122232425262728# For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html[mysqld]skip-grant-tables## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid 登录之后修改默认密码 12345# 方式一ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;@Escher123456&#x27;;# 方式二set password for root@localhost = password(&#x27;@Escher123456123456&#x27;); 修改密码后，可以修改mysql的默认密码校验策略设置简单密码 12345678910111213141516171819mysql&gt; SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;+--------------------------------------+--------+| Variable_name | Value |+--------------------------------------+--------+| validate_password_check_user_name | OFF || validate_password_dictionary_file | || validate_password_length | 8 || validate_password_mixed_case_count | 1 || validate_password_number_count | 1 || validate_password_policy | MEDIUM || validate_password_special_char_count | 1 |+--------------------------------------+--------+7 rows in set (0.00 sec)mysql&gt; set global validate_password_policy=LOW;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global validate_password_length=4;Query OK, 0 rows affected (0.00 sec) 密码的策略 validate_password_length 固定密码的总长度； validate_password_dictionary_file 指定密码验证的文件路径； validate_password_mixed_case_count 整个密码中至少要包含大/小写字母的总个数； validate_password_number_count 整个密码中至少要包含阿拉伯数字的个数； validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM； LOW：只验证长度； MEDIUM：验证长度、数字、大小写、特殊字符； STRONG：验证长度、数字、大小写、特殊字符、字典文件； validate_password_special_char_count 整个密码中至少要包含特殊字符的个数； 设置远程登录 1234567891011121314151617mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select user,host from user;+---------------+-----------+| user | host |+---------------+-----------+| mysql.session | localhost || mysql.sys | localhost || root | localhost |+---------------+-----------+3 rows in set (0.00 sec)# ALL PRIVILEGES 赋予所有的权限(select,update,delete,insert) *.*所有的数据库和表 WITH GRANT OPTION是赋权的作用mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;root&#x27; WITH GRANT OPTION;Query OK, 0 rows affected, 1 warning (0.00 sec) 最后刷新权限 12mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)","categories":[{"name":"软件安装","slug":"软件安装","permalink":"http://liujun1997.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"Mysql Linux","slug":"Mysql-Linux","permalink":"http://liujun1997.github.io/tags/Mysql-Linux/"}]},{"title":"Linux磁盘/分区/文件系统","slug":"Linux磁盘-分区-文件系统","date":"2021-10-11T08:59:47.000Z","updated":"2022-04-23T12:25:27.943Z","comments":true,"path":"2021/10/11/Linux磁盘-分区-文件系统/","link":"","permalink":"http://liujun1997.github.io/2021/10/11/Linux%E7%A3%81%E7%9B%98-%E5%88%86%E5%8C%BA-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"1.背景 最近在帮朋友解决一个挂载硬盘的问题，发现自己对磁盘分区文件系统了解比较少，因此写这篇文章记录下。 2.磁盘 在linux中，万物皆文件。硬件这些设备在linux中称为设备文件，磁盘在linux中叫做块设备文件。 2.1 磁盘的分类 当下比较常见的硬盘分为SCSI，STAT，SAS，SSD硬盘，比较古老的有IDE硬盘，由于效率比较低，已经在消费市场少见了。 SCSI硬盘: 采用SCSI接口，优点：性能，稳定好，缺点是价格昂贵，所以主要使用在服务器市场。 SAS是Serial Attached SCSI 的缩写，比SCSI硬盘更加昂贵。 STAT: Serial ATA接口硬盘，采用串行接口，主要在消费市场使用。 固态硬盘是用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元(FLASH芯片、DRAM芯片)组成。其主要特点是没有传统硬盘的机械结构，读写速度非常快 2.2 硬盘原理 硬盘的构造如下图所示，磁盘的构造主要由盘面，磁道，磁头，柱面，扇区这几部分组成。 ​ 盘面(platter)：盘面是磁盘记录信息的载体，主要由铝合金材料组成。上面涂有磁性物质。上下两面都可以使用。 磁道(track)：盘面上有许多个同心圆环，这个轨道就称之为磁道。每个盘面上一般有300-1024个磁道。从外到里可分为0-n磁道。信息的存储从0磁道开始，一直到离主轴最近的区域，这个区域叫做着陆区(loading Zone)，这个区域不存储信息。 扇区(setors): 存储信息主要在这个区域，主要存储512byte数据和寻址信息，寻址信息主要包括，磁头号(盘面号)，磁道号(柱面号)，扇区在磁道上的位置(扇区号)，这个三维地址组成了信息在磁盘上的唯一标识地址。用于磁头读取或写入信息时比对。 柱面(cylinder): 磁盘上所有盘面上同一半径组成的圆柱面，磁盘的读写是按照柱面进行的，在同一柱面上，磁头从上到下编号0-n，读写顺序也是从上到下的，同一柱面的所有磁头全部读取完成，才切换到下一个柱面。 磁盘的容量: 不难看出，磁盘的容量由三部分决定,柱面数，磁头数，扇区数 。磁盘容量= 柱面数x磁头数x扇区数x512byte 硬盘的寻址模式: C/H/S（Cylinder/Head/Sector）寻址模式，也可以称为三维地址模式，这是硬盘最早采用的寻址模式，当时硬盘的容量还非常小，人们采用与软盘类似的结构生产硬盘，也就是硬盘盘片的每一条磁道都具有相同的扇区数，由此产生了所谓的3D参数（Disk Geometry），既磁头数（Heads）、柱面数（Cylinders）、 扇区数（Sectors），以及相应的寻址方式。 早期硬盘的的同一磁盘的扇区数是相同的，这样外圈的周长大，但是扇区数还是一样，这样就造成磁盘空间浪费。，人们改用等密度结构生产硬盘，也就是说，外圈磁道的扇区比内圈磁道多。采用这种结构后，硬盘不再具有实际的3D参数，寻址方式也改为线性寻址，即以扇区为单位进行寻址，这种寻址模式叫做LBA，全称为Logic Block Address（即扇区的逻辑块地址）而在LBA方式下，系统把所有的物理扇区都按照某种方式或规则看做是一个线性编号的扇区，即从0到某个最大值方式排列，并连成一条线，把LBA作为一个整体来对待，而不再是具体的实际的C/H/S值，这样只用一个序数就确定了一个惟一的物理扇区，显然线性地址是物理扇区的逻辑地址。为了与使用C/H/S寻址的老软件兼容（如使用BIOS Int13H接口的软件）在硬盘控制器内部安装了s一个地址翻译器，由它负责将C/H/S参数翻译成LBA地址。 从C/H/S到LBA的转换公式： 这里规定用 C表示当前柱面号， H表示当前磁头号， S表示当前扇区号， CS表示起始柱面号，HS表示起始磁头号，SS表示起始扇区号，PS表示每磁道扇区数，PH表示每柱面磁道数，所以公式为： LBA=（C–CS）﹡PH﹡PS+（H–HS）﹡PS+（S–SS） 磁盘的读写原理：系统将文件存储到磁盘上时，按柱面、磁头、扇区的方式进行，即最先是第1磁道的第一磁头下（也就是第1盘面的第一磁道）的所有扇区，然后，是同一柱面的下一磁头，……，一个柱面存储满后就推进到下一个柱面，直到把文件内容全部写入磁盘。 系统也以相同的顺序读出数据。读出数据时通过告诉磁盘控制器要读出扇区所在的柱面号、磁头号和扇区号（物理地址的三个组成部分）进行。 扇区到来时，磁盘控制器读出每个扇区的头标，把这些头标中的地址信息与 期待检出的磁头和柱面号做比较（即寻道），然后，寻找要求的扇区号。待磁盘控制器找到该扇区头标时，根据其任务是写扇区还是读扇区，来决定是转换写电路， 还是读出数据和尾部记录。 3.分区3.1 硬盘为什么要分区 硬盘安全：如果硬盘只有一个分区，一旦这个分区发生损坏，则导致整个硬盘的数据发生丢失。 多个文件系统共存：如果想在同一块硬盘上使用多个文件系统，可以通过多个分区，格式化成不同的文件系统使用。 提高磁盘利用率：可以用不同的区块大小来格式化分区，如果有很多1K的文件，而硬盘分区区块大小为4K，那么每存储一个文件将会浪费3K空间。这时我们需要取这些文件大小的平均值进行区块大小的划分。 提高系统稳定性：如果只分为一个区，当用户的数据填满整个磁盘，则会导致系统挂起。 3.2 硬盘分区的在Linux上的形式 使用fdisk工具可以查看系统磁盘和磁盘的分区情况。下图中，有一个/dev/sda块设备文件，一共有976773167 扇区，共有465.8 G容量，在Linux中，STAT接口和SCSI接口硬盘的主设备号是sd[a-z]，如果是早期的IDE硬盘，则为hd[a-z]，下面的/dev/sda1,/dev/sda2代表这个磁盘的分区，后面的数字带表分区号。 123456789101112root@raspberrypi:~# fdisk -l Disk /dev/sda: 465.8 GiB, 500107861504 bytes, 976773167 sectorsDisk model: Externa Units: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 33553920 bytesDisklabel type: gptDisk identifier: 08757A4D-B822-4E26-80CB-5D6374771736Device Start End Sectors Size Type/dev/sda1 40 409639 409600 200M EFI System/dev/sda2 411648 976248831 975837184 465.3G Microsoft basic data 使用lsblk命令可以查看系统上所有块设备个数和分区及挂载情况，下图中，系统一共有2个磁盘，/dev/sda和/dev/mmcblk0,sda磁盘上有两个分区，还没有挂载到系统，mmcblk0y有两个分区，mmcblk0p1分区是系统的引导主分区，挂载在/boot上，mmcblk0p2分区是系统的数据分区，挂载在根目录上。 12345678root@raspberrypi:~# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 465.8G 0 disk ├─sda1 8:1 0 200M 0 part └─sda2 8:2 0 465.3G 0 part mmcblk0 179:0 0 14.9G 0 disk ├─mmcblk0p1 179:1 0 256M 0 part /boot└─mmcblk0p2 179:2 0 14.6G 0 part / 磁盘的分区由主分区，扩展分区，逻辑分区组成，磁盘最多有4个主分区，其中扩展分区也是一个主分区，并且最多只能有一个扩展分区，但可以在扩展分区上创建多个逻辑分区。因此主分区(包括扩展分区)的范围是 1-4，逻辑分区从 5 开始。对于逻辑分区，Linux 规定它们必须建立在扩展分区上，而不是建立在主分区上。 主分区的作用是用来启动操作系统的，主要存放操作系统的启动或引导程序，因此建议操作系统的引导程序都放在主分区，比如 Linux 的 /boot 分区，最好放在主分区上： 12root@raspberrypi:~# df -h | grep boot/dev/mmcblk0p1 253M 49M 204M 20% /boot 3.3 硬盘怎么分区 主要利用fdisk工具划分磁盘分区，使用虚拟机挂载1个10G的磁盘，fdisk /dev/${分区磁盘}，p可以查看磁盘的分区状态，现在是未分区的状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[root@CentOS7 ~]# fdisk -l /dev/sdbDisk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytes[root@CentOS7 ~]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0xde518367.The device presents a logical sector size that is smaller thanthe physical sector size. Aligning to a physical sector (or optimalI/O) size boundary is recommended, or performance may be impacted.Command (m for help): pDisk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisk label type: dosDisk identifier: 0xde518367 Device Boot Start End Blocks Id System#新增一个分区Command (m for help): nPartition type: p primary (0 primary, 0 extended, 4 free) e extended#选择分区类型 p为主分区（最大为4个） e为扩展分区(最多只有1个扩展分区)Select (default p): pPartition number (1-4, default 1): 1#开始扇区First sector (2048-20971519, default 2048): 2048#结束扇区Last sector, +sectors or +size&#123;K,M,G&#125; (2048-20971519, default 20971519): +1GPartition 1 of type Linux and of size 1 GiB is set #写入磁盘Command (m for help): w#改变分区的文件系统Command (m for help): t#查看支持的文件系统(82 swap 8r inux 8e lvm)Command (m for help): L 建好分区后，需要对分区格式化对应的文件系统，然后挂载到系统的目录上去，这样才能使用 1234567891011121314151617181920212223242526272829303132#查看支持的文件格式[root@CentOS7 /]# ls /sbin/mkfs*/sbin/mkfs /sbin/mkfs.cramfs /sbin/mkfs.ext3 /sbin/mkfs.minix/sbin/mkfs.btrfs /sbin/mkfs.ext2 /sbin/mkfs.ext4 /sbin/mkfs.xfs#格式化分区[root@CentOS7 /]# mkfs.ext4 /dev/sdb1mke2fs 1.42.9 (28-Dec-2013)Discarding device blocks: doneFilesystem label=OS type: LinuxBlock size=4096 (log=2)Fragment size=4096 (log=2)Stride=0 blocks, Stripe width=0 blocks65536 inodes, 262144 blocks13107 blocks (5.00%) reserved for the super userFirst data block=0Maximum filesystem blocks=2684354568 block groups32768 blocks per group, 32768 fragments per group8192 inodes per groupSuperblock backups stored on blocks: 32768, 98304, 163840, 229376Allocating group tables: doneWriting inode tables: doneCreating journal (8192 blocks): doneWriting superblocks and filesystem accounting information: done#挂载分区[root@CentOS7 /]# mkdir /escher[root@CentOS7 /]# mount /dev/sdsda sda1 sda2 sdb sdb1[root@CentOS7 /]# mount /dev/sdb1 /escher 4.文件系统 在给磁盘分区后，需要格式化分区，让分区格式化为系统可以识别的文件系统，window支持fat，fat32，ntfs文件系统，Linux支持ext2，ext3，ext4，xfs文件系统，window就不能识别ext3文件系统的磁盘，所以要根据操作系统格式化磁盘。 硬盘的最小存储单元是扇区，每个扇区可以储存512byte数据，如果想要存储大数据，就需要硬盘磁头读写许多次，效率太低，所以有了block的概念，逻辑块是格式化文件系统中指定最小的存储单元。这个大小是扇区的2次方，在读取大数据时，磁头可以一次读取一块，这样磁头的读取次数大大降低。提高了IO的效率，当然块大小必须适中，块大小小了，就会导致读取效率低，如果块大了，在存储小文件时，就会浪费大量的存储空间。必须在文件的读取效率与空间利用率中做取舍。所以在格式化分区时，需要考虑使用情景。 VFS(Virual File System): 虚拟文件系统时Linux中一种抽象的文件系统，试想一下，当操作系统需要适配多个文件系统时，每个文件系统的接口肯定不是相同的。所以，VFS就把这些不同的文件系统做一个抽象，提供统一的API访问接口，这样，用户空间就不用关心不同文件系统中不一样的API了。VFS所提供的这些统一的API，再经过System Call包装一下，用户空间就可以经过SCI的系统调用来操作不同的文件系统。 5.LVM分区5.1lvm是什么 LVM(Logical Volume Manager), 逻辑卷管理, 是一种将一至多个硬盘的分区在逻辑上进行组合, 当成一个大硬盘来使用.当硬盘空间不足时, 可以动态地添加其它硬盘的分区到已有的卷组中 —— 磁盘空间的动态管理. 5.2 为什么使用lvm 试想一下，当我们挂载的分区的磁盘容量使用完成后，如果想要扩容，只能做数据备份迁移到另外一个分区上面。或者使用软连接到其他分区。 如果使用了lvm之后，只需要扩展逻辑卷大小，就能够扩大容量。如果将多个分区加入到lvm卷组中，数据还可以跨分区访问。如果使用多个磁盘，建议使用lvm管理磁盘 5.3 LVM相关概念 PV(Physical Volume): 物理卷, 处于LVM最底层, 可以是物理硬盘或者分区; PP(Physical Extend): 物理区域, PV中可以用于分配的最小存储单元, 可以在创建PV的时候指定, 如1M, 2M, 4M, 8M…..组成同一VG中所有PV的PE大小应该相同; VG(Volume Group): 卷组, 建立在PV之上, 可以含有一个到多个PV; LV(Logical Volume): 逻辑卷, 建立在VG之上, 相当于原来分区的概念, 不过大小可以动态改变. 5.4 LVM使用 创建物理卷 12[root@CentOS7 ~]# pvcreate /dev/sdb1 Physical volume &quot;/dev/sdb1&quot; successfully created. 创建卷组 12[root@CentOS7 ~]# vgcreate test /dev/sdb1 Volume group &quot;test&quot; successfully created 创建逻辑卷 12[root@CentOS7 ~]# lvcreate -L 100M -n escher test Logical volume &quot;escher&quot; created. 格式化文件系统 1[root@CentOS7 ~]# mkfs.ext4 /dev/test/escher 挂载 参考 (http://cn.linux.vbird.org/linux_basic/fedora_4/0230filesystem-fc4.php) (https://cloud.tencent.com/developer/article/1721138) (https://zhuanlan.zhihu.com/p/34915311)","categories":[{"name":"运维","slug":"运维","permalink":"http://liujun1997.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Linux 磁盘分区","slug":"Linux-磁盘分区","permalink":"http://liujun1997.github.io/tags/Linux-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"}]},{"title":"Shell-4","slug":"shell-4","date":"2021-09-04T12:34:53.000Z","updated":"2022-04-23T12:25:27.943Z","comments":true,"path":"2021/09/04/shell-4/","link":"","permalink":"http://liujun1997.github.io/2021/09/04/shell-4/","excerpt":"","text":"Shell好用的工具： cut介绍cut 译为“剪切, 切割” , 是一个强大文本处理工具，它可以将文本按列进行划分的文本处理。cut命令逐行读入文本，然后按列划分字段并进行提取、输出等操作。 语法1cut [options] filename options参数说明 选项参数 功能 -f 提取范围 列号，获取第几列 -d 自定义分隔符 自定义分隔符，默认为制表符。 -c 提取范围 以字符为单位进行分割 -b 提取范围 以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。 -n 与“-b”选项连用，不分割多字节字符； 提取范围说明 提取范围 说明 n- 提取指定第n列或字符或字节后面所有数据 n-m 提取指定第n列或字符或字节到第m列或字符或字节中间的所有数据 -m 提取指定第m列或字符或字节前面所有数据 n1,n2,… 提前指定枚举列的所有数据 示例：切割提取指定列数据cut1.txt文件数据准备 1touch cut1.txt 编辑文件添加内容 1234AA itheima 11 XXBB itcast 22 XXXCC Shell 33 XXXXDD it 44 XXXXXXX 提取文件中第一列数据 1cut cut1.txt -d &quot; &quot; -f 1 提取文件中第一列,第三列, 枚举查找 1cut cut1.txt -d &quot; &quot; -f 1,3 提取文件中第二列,第三列,第四列, 范围查找 提取文件中第一列后面所有列的数据 1cut cut1.txt -d &quot; &quot; -f 2- 提起文件中结束列前面所有列的数据 12cut -d &quot; &quot; -f -2 cut1.txt# -2 提取指定列前面所有列数据 运行效果 示例: 切割提取指定字符数据提取每行前3个字符 1cut cut1.txt -c1-3 运行效果 提取每行第4个字符以后的数据 1cut cut1.txt -c 4- 运行效果 提取每行第3个字符前面所有字符 1cut cut1.txt -c -3 运行效果 示例：切割提取指定字节数据提取字符串”abc传智播客” 前3个字节 1echo &quot;abc传智播客&quot; | cut -b -3 运行效果 提取字符串”abc传智播客” 前4个字节 1echo &quot;abc传智播客&quot; | cut -b -4 运行效果 提取字符串”abc传智播客” 前6个字节 12echo &quot;abc传智播客&quot; | cut -b -6# 由于linux系统默认utf-8码表, 所以一个汉字占3个字节 运行效果 提取字符串”abc传智播客” 前4个字节, 就可以将汉字 “传”输出, 12echo &quot;abc传智播客&quot; | cut -nb -4# -n 取消多字节字符分割直接输出 运行效果 示例：切割提取指定单词数据在cut1.txt文件中切割出”itheima” 1cat cut1.txt | grep itheima | cut -d &quot; &quot; -f 2 示例：切割提取bash进程的PID号命令 1ps -aux | grep &#x27;bash&#x27; | head -n 1 | cut -d &quot; &quot; -f 8 运行效果 示例：切割提取IP地址1ifconfig | grep broadcast | cut -d &quot; &quot; -f 10 运行效果 小结cut的作用 一个强大文本处理工具，它可以将文本按列进行划分的文本处理。cut命令逐行读入文本，然后按列划分字段并进行提取、输出等操作。 cut切割提取列 cut 文件或数据 -d 分隔符切割 -f 提取第X列 cut切割提取字符 cut 文件或数据 -c 提取字符范围 cut切割提取字节 cut 文件或数据 -nb 提取直接范围 Shell好用的工具：sed目标使用sed编辑文件替换文件中的单词 编写在文件中插入或修改行的sed程序 使用sed作为过滤器来过滤管道数据命令 介绍sed （stream editor, 流编辑器） 是Linux下一款功能强大的非交互流式文本编辑器(vim是交互式文本编辑器)，可以对文本文件的每一行数据匹配查询之后进行增、删、改、查等操作，支持按行、按字段、按正则匹配文本内容，灵活方便，特别适合于大文件的编辑. sed是一种流编辑器，它一次处理一行内容, 将这行放入缓存(存区空间称为：模式空间)，然后才对这行进行处理，处理完后，将缓存区的内容发送到终端。 sed处理数据原理 语法1234sed [选项参数] [模式匹配/sed程序命令] [文件名]# 模式匹配,sed会读取每一行数据到模式空间中, 之后判断当前行是否符合模式匹配要求,符合要求就会# 执行sed程序命令, 否则不会执行sed程序命令;如果不写匹配模式,那么每一行都会执行sex程序命令 选项参数说明 选项参数 功能 -e 直接在指令列模式上进行sed的动作编辑。它告诉sed将下一个参数解释为一个sed指令，只有当命令行上给出多个sed指令时才需要使用-e选项;一行命令语句可以执行多条sed命令 -i 直接对内容进行修改，不加-i时默认只是预览，不会对文件做实际修改 -f 后跟保存了sed指令的文件 -n 取消默认输出，sed默认会输出所有文本内容，使用-n参数后只显示处理过的行 -r ruguler 使用扩展正则表达式，默认情况sed只识别基本正则表达式 * sed程序命令功能描述 命令 功能描述 a add新增，a的后面可以接字串，在下一行出现 c change更改, 更改匹配行的内容 d delete删除, 删除匹配的内容 i insert插入, 向匹配行前插入内容 p print打印, 打印出匹配的内容，通常与-n选项和用 s substitute替换, 替换掉匹配的内容 = 用来打印被匹配的行的行号 n 读取下一行，遇到n时会自动跳入下一行 特殊符号 命令 功能描述 ! 就像一个sed命令，放在限制条件后面, 对指定行以外的所有行应用命令(取反) {sed命令1;sed命令2} 多个命令操作同一个的行 数据准备sed.txt文件内容 12345ABCitheima itheimaitcast123itheima 示例：向文件中添加数据演示1: 指定行号的前或后面添加数据向第三行后面添加hello 1sed &#x27;3ahello&#x27; sed.txt 3 , 代表第三行 a, 代表在后面添加, 出现在下一行 注意这里没有修改源文件 运行效果 向第三行前面添加hello 1sed &#x27;3ihello&#x27; sed.txt 3 , 代表第三行 i, 代表在前面添加, 出现在上一行 注意这里没有修改源文件 运行效果 演示2: 指定内容前或后面添加数据向内容 itheima 后面添加 hello ，如果文件中有多行包括 ``itheima ，则每一行后面都会添加 1sed &#x27;/itheima/ahello&#x27; sed.txt 运行效果 向内容 itheima 前面添加 hello ，如果文件中有多行包括 ``itheima ，则每一行前面都会添加 1sed &#x27;/itheima/ihello&#x27; sed.txt 运行效果 演示3: 在最后一行前或后添加hello在最后一行后面添加hello 1sed &#x27;$ahello&#x27; sed.txt $a: 最后一行后面添加 运行效果 在最后一行前面添加hello 1sed &#x27;$ihello&#x27; sed.txt $i: 最后一行前面添加 运行效果 示例: 删除文件中的数据演示1: 删除第2行命令 123sed &#x27;2d&#x27; sed.txt# d 用于删除# 2d 删除第2行 运行效果 命令: 删除第1行,第4行数据 1sed &#x27;1d;4d&#x27; sed.txt 运行效果 演示2: 删除奇数行从第一行开始删除，每隔2行就删掉一行 12sed &#x27;1~2d&#x27; sed.txt# 1~2 从第1行开始, 每隔2行 运行效果 演示3: 删除指定范围的多行数据删除从第1行到第3行的数据 12sed &#x27;1,3d&#x27; sed.txt# 1,3 从指定第1行开始到第3行结束 运行效果 演示3: 删除指定范围取反的多行数据删除从第1行到第3行取反的数据 12sed &#x27;1,3!d&#x27; sed.txt# 1,3! 从指定第1行开始到第3行结束取反, 就是不在这个范围的行 运行效果 演示4: 删除最后一行命令 1sed &#x27;$d&#x27; sed.txt 运行效果 演示5: 删除匹配itheima的行命令 1sed &#x27;/itheima/d&#x27; sed.txt 运行效果 演示6: 删除匹配行到最后一行删除匹配itheima行到最后一行 , 命令 12sed &#x27;/itheima/,$d&#x27; sed.txt# , 代表范围匹配 运行效果 演示7: 删除匹配行及其后面一行删除匹配itheima行及其后面一行 1sed &#x27;/itheima/,+1d&#x27; sed.txt 运行效果 演示9: 删除不匹配的行删除不匹配 itheima 或 itcast 的行 1234sed &#x27;/itheima\\|itcast/!d&#x27; sed.txt# \\| 是正则表达式的或者 这里|需要转义, 所以为\\|# ! 取反 运行效果 示例：更改文件中的数据演示1:将文件的第一行修改为hello命令 1sed &#x27;1chello&#x27; sed.txt 运行效果 演示2: 将包含itheima的行修改为hello命令 1sed &#x27;/itheima/chello&#x27; sed.txt 运行效果 演示3: 将最后一行修改为hello命令 1sed &#x27;$chello&#x27; sed.txt 运行效果 演示4: 将文件中的itheima替换为hello将文件中的itheima替换为hello,默认只替换每行第一个itheima 1sed &#x27;s/itheima/hello/&#x27; sed.txt 运行效果 注意 &#39;s/itheima/hello/&#39; 最后一个/ 不可少 将文本中所有的itheima都替换为hello, 全局替换 12sed &#x27;s/itheima/hello/g&#x27; sed.txt# g 代表匹配全局所有符合的字符 演示5: 将每行中第二个匹配替换将每行中第二个匹配的itheima替换为hello 命令 1sed &#x27;s/itheima/hello/2&#x27; sex.txt 运行效果 演示6: 替换后的内容写入文件将每行中第二个匹配的itheima替换为hello , 将替换后的内容写入到sed2.txt文件中 1234567# 第一种方式sed -n &#x27;s/itheima/hello/2pw sed2.txt&#x27; sed.txt# w写入# p打印, -n只是获取# 第二种方式sed -n &#x27;s/itheima/hello/2p &#x27; sed.txt &gt; sed2.txt 运行效果 演示7: 正则表达式匹配替换匹配有 i 的行，替换匹配行中 t 后的所有内容为空 12sed &#x27;/i/s/t.*//g&#x27; sed.txt# /t.*/ 表示逗号后的所又内容 运行效果 演示8: 每行末尾拼接test12sed &#x27;s/$/&amp; test&#x27; sed.txt# &amp; 用于拼接 运行效果 演示9: 每行行首添加注释 #命令 1sed &#x27;s/^/#/&#x27; sed.txt 运行效果 示例: 查询文件或管道中的数据需求1: 查询含有 itcast 的行数据命令 1sed -n &#x27;/itcast/p&#x27; sed.txt 运行效果 需求2: 管道过滤查询管道查询所有进程中含有sshd的进程信息命令 1ps -aux | sed -n &#x27;/sshd/p&#x27; 运行效果 示例: 多个sed程序命令执行将sed.txt文件中的第1行删除并将 itheima 替换为 itcast 12345# 第一种方式, 多个sed程序命令 在每个命令之前使用 -e 参数sed -e &#x27;1d&#x27; -e &#x27;s/itheima/itcast/g&#x27; sed.txt # 第二种方式sed &#x27;1d;s/itheima/itcast/g&#x27; sed.txt 运行效果 sed高级用法: 缓存区数据交换模式空间与暂存空间介绍 首先需要明白, sed处理文件是逐行处理的, 即读取一行处理一行,输出一行; sed把文件读出来每一行存放的空间叫模式空间, 会在该空间中对读到的内容做相应处理; 此外sed还有一个额外的空间即暂存空间, 暂存空间刚开始里边只有个空行, 记住这一点; sed可使用相应的命令从模式空间往暂存空间放入内容或从暂存空间取内容放入模式空间; 2个缓存空间传输数据的目的是为了更好的处理数据, 一会参考案例学习 关于缓存区sed程度命令 命令 含义 h 将模式空间里面的内容复制到暂存空间缓存区(覆盖方式) H 将模式空间里面的内容复制到暂存空间缓存区(追加方式) g 将暂存空间里面的内容复制到模式空间缓存区(覆盖方式) G 将暂存空间里面的内容复制到模式空间缓存区(追加方式) x 交换2个空间的内容 示例: 缓存空间数据交换演示1: 第一行粘贴到最后1行将模式空间第一行复制到暂存空间(覆盖方式),并将暂存空间的内容复制到模式空间中的最后一行(追加方式) 123sed &#x27;1h;$G&#x27; sed.txt# 1h 从模式空间中将第一行数据复制到暂存空间(覆盖方式)# $G 将暂存空间中的内容复制到模式空间中最后一行(追加方式) 运行效果 演示2: 第一行删除后粘贴到最后1行将模式空间第一行复制到暂存空间(覆盖方式)并删除, 最后将暂存空间的内容复制到模式空间中的最后一行(追加方式) 12sed &#x27;1&#123;h;d&#125;;$G&#x27; sed.txt# 1&#123;h;d&#125;对模式空间中的第一行数据同时进行复制到暂存空间(覆盖方式)和删除模式空间中的第一行数据 运行效果 演示3: 第一行数据复制粘贴替换其他行数据将模式空间第一行复制到暂存空间(覆盖方式), 最后将暂存空间的内容复制到模式空间中替换从第2行开始到最后一行的每一行数据(覆盖方式) 1sed &#x27;1h;2,$g&#x27; sed.txt 运行命令 演示4: 将前3行数据数据复制粘贴到最后一行将前3行数据复制到暂存空间(追加方式), 之后将暂存空间的所有内容复制粘贴到模式空间最后一行(追加方式) 1sed &#x27;1,3H;$G&#x27; sed.txt 运行效果 示例: 给每一行添加空行插入空行 123sed G -i sed.txt# G 每行后面添加一个空行# -i 修改源文件 运行效果 示例: 删除所有的空行命令 1sed -i &#x27;/^$/d&#x27; sed.txt 运行效果 Shell好用的工具：awk介绍awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时,显得尤为强大简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理, 因为切开的部分使用awk可以定义变量,运算符, 使用流程控制语句进行深度加工与分析。 创始人 Alfred V. Aho、Peter J. Weinberger和Brian W. Kernighan awk由来是姓氏的首字母 语法1awk [options] &#x27;pattern&#123;action&#125;&#x27; &#123;filenames&#125; pattern：表示AWK在数据中查找的内容，就是匹配模式 action：在找到匹配内容时所执行的一系列命令 选项参数说明 选项参数 功能 -F 指定输入文件拆分分隔符 -v 赋值一个用户定义变量 awk内置变量 内置变量 含义 ARGC 命令行参数个数 ARGV 命令行参数排列 ENVIRON 支持队列中系统环境变量的使用 FILENAME awk浏览的文件名 FNR 浏览文件的记录数 FS 设置输入域分隔符，等价于命令行 -F选项 NF 浏览记录的域的个数, 根据分隔符分割后的列数 NR 已读的记录数, 也是行号 OFS 输出域分隔符 ORS 输出记录分隔符 RS 控制记录分隔符 $n $0变量是指整条记录。$1表示当前行的第一个域,$2表示当前行的第二个域,……以此类推。 $NF $NF是number finally,表示最后一列的信息，跟变量NF是有区别的，变量NF统计的是每行列的总数 数据准备1cp /etc/passwd ./ 示例 : 默认每行空格切割数据命令 1echo &quot;abc 123 456&quot; | awk &#x27;&#123;print $1&quot;&amp;&quot;$2&quot;&amp;&quot;$3&#125;&#x27; 运行效果 示例: 打印含有匹配信息的行搜索passwd文件有root关键字的所有行 12awk &#x27;/root/&#x27; passwd# &#x27;/root/&#x27; 是查找匹配模式, 没有action命令, 默认输出所有符合的行数据 运行效果 示例: 打印匹配行中第7列数据搜索passwd文件有root关键字的所有行, 然后以”:”拆分并打印输出第7列 12awk -F: &#x27;/root/&#123;print $7&#125;&#x27; passwd# -F: 以&#x27;:&#x27;分隔符拆分每一个列(域)数据 运行效果 示例: 打印文件每行属性信息统计passwd: 文件名，每行的行号，每行的列数，对应的完整行内容: 12awk -F &#x27;:&#x27; &#x27;&#123;print &quot;文件名:&quot; FILENAME &quot;,行号:&quot; NR &quot;,列数:&quot; NF &quot;,内容:&quot; $0&#125;&#x27; passwd# &quot;文件名:&quot; 用于拼接字符串 运行效果 使用printf替代print,可以让代码阅读型更好 12345awk -F &#x27;:&#x27; &#x27;&#123;printf(&quot;文件名:%5s,行号:%2s, 列数:%1s, 内容:%2s\\n&quot;,FILENAME,NR,NF,$O)&#125;&#x27; passwd# printf(格式字符串,变量1,变量2,...)# 格式字符串: %ns 输出字符串,n 是数字，指代输出几个字符, n不指定自动占长度# 格式字符串: %ni 输出整数,n 是数字，指代输出几个数字# 格式字符串: %m.nf 输出浮点数,m 和 n 是数字，指代输出的整数位数和小数位数。如 %8.2f 代表共输出 8 位数，其中 2 位是小数，6 位是整数； 运行效果 示例: 打印第二行信息打印/etc/passwd/的第二行信息 1awk -F &#x27;:&#x27; &#x27;NR==2&#123;printf(&quot;filename:%s,%s\\n&quot;,FILENAME,$0)&#125;&#x27; passwd 运行效果 示例: 查找以c开头的资源awk过滤的使用, 查找当前目录下文件名以c开头的文件列表 1ls -a | awk &#x27;/^c/&#x27; 运行效果 示例: 打印第一列按照”:” 分割查询第一列打印输出 1awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27; passwd 运行效果 示例: 打印最后1列按照”:” 分割查询最后一列打印输出 1awk -F: &#x27;&#123;print $NF&#125;&#x27; passwd 运行效果 示例: 打印倒数第二列按照”:” 分割查询倒数第二列打印输出 12awk -F: &#x27;&#123;print $(NF-1)&#125;&#x27; passwd# $(NF-N) N是几, 就是倒数第几列 运行效果 示例: 打印10到20行的第一列获取第10到20行的第一列的信息 1awk -F: &#x27;&#123;if(NR&gt;=10 &amp;&amp; NR&lt;=20) print $1&#125;&#x27; passwd 运行效果 示例: 多分隔符使用“one:two/three”字符串按照多个分隔符”:”或者”/“ 分割, 并打印分割后每个列数据 1echo &quot;one:two/three&quot; | awk -F &#x27;[:/]&#x27; &#x27;&#123;printf(&quot;%s\\n%s\\n%s\\n%s\\n&quot;,$0,$1,$2,$3)&#125;&#x27; 运行效果 示例: 添加开始与结束内容给数据添加开始与结束 123echo -e &quot;abc\\nabc&quot; | awk &#x27;BEGIN&#123;print &quot;开始...&quot;&#125; &#123;print $0&#125; END&#123;print &quot;结束...&quot;&#125;&#x27;# BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。 运行效果 示例 : 使用循环拼接分割后的字符串“abc itheima itcast 21” 使用空格分割后, 通过循环拼接在一起 123echo &quot;abc itheima itcast 21&quot; | awk -v str=&quot;&quot; -F &#x27;[ ]+&#x27; &#x27;&#123;for(n=1;n&lt;=NF;n++)&#123; str=str$n&#125; print str &#125;&#x27;# -v 定义变量 运行效果 示例: 操作指定数字运算将passwd文件中的用户id增加数值1并输出 1echo &quot;2.1&quot; | awk -v i=1 &#x27;&#123;print $0+i&#125;&#x27; 运行效果 示例: 切割ip切割IP 1ifconfig | awk &#x27;/broadcast/&#123;print&#125;&#x27; | awk -F &quot; &quot; &#x27;&#123;print $2&#125;&#x27; 运行效果 示例: 显示空行行号查询sed.txt中空行所在的行号 1sed &#x27;G&#x27; sed.txt | awk &#x27;/^$/&#123;print NR&#125;&#x27; 运行效果 小结grep , sed ,awk , cut 文本字符串操作四剑客的区别 grep：用于查找匹配的行 cut： 截取数据. 截取某个文件中的列, 重点是按照列分割, 这个命令不适合截取文件中有多个空白字符的字段 sed： 增删改查数据. sed用于在文件中以行来截取数据进行增\\删\\改\\查 awk：截取分析数据. 可以在某个文件中是以竖列来截取分析数据, 如果字段之间含有很多空白字符也可以获取需要的数据, awk是一种语言,可以深入分析文件数据 Shell好用的工具：sort目标能够使用sort对字符串升序或降序排序 能够使用sort 对数字升序或降序 能够使用sort 对多列进行排序 介绍sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出或重定向输出到指定文件。 语法1sort (options) 参数 选项 说明 ==-n== number,依照数值的大小排序 ==-r== reverse, 以相反的顺序来排序 ==-t 分隔字符== 设置排序时所用的分隔字符, 默认空格是分隔符 ==-k== 指定需要排序的列 -d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。 -f 排序时，将小写字母视为大写字母 -b 忽略每行前面开始出的空格字符 ==-o 输出文件== 将排序后的结果存入指定的文件 -u 意味着是唯一的(unique)，输出的结果是去完重了的 -m 将几个排序好的文件进行合并 参数：指定待排序的文件列表 数据准备sort.txt文本文件代码 1234567张三 30 李四 95 播仔 85 播仔 85播仔 86AA 85播妞 100 示例1: 数字升序按照“ ”空格分割后的第2列数字升序排序。 123sort -t &quot; &quot; -k2n,2 sort.txt# -t &quot; &quot; 代表使用空格分隔符拆分列# -k 2n,2 代表根据从第2列开始到第2列结束进行数字升序, 仅对第2列排序 运行效果 示例2: 数字升序去重先按照“ ”空格分割后的, 然后,按照第2列数字升序排序, 最后对所有列去重 1sort -t &quot; &quot; -k2n,2 -uk1,2 sort.txt 运行效果 注意: 先排序再去重 示例3: 数字升序去重结果保存到文件命令 1sort -t &quot; &quot; -k2n,2 -uk1,2 -o sort2.txt sort.txt 运行效果 示例4: 数字降序去重先按照“ ”空格分割后的, 然后,按照第2列数字降序排序, 最后对所有列去重 1sort -t &quot; &quot; -k2nr,2 -uk1,2 sort.txt 运行效果 示例5: 多列排序数据准备sort3.txt 12345678910111213公司A,部门A,3公司A,部门B,0公司A,部门C,10公司A,部门D,9公司B,部门A,30公司B,部门B,40公司B,部门C,43公司B,部门D,1公司C,部门A,30公司C,部门B,9公司C,部门C,100公司C,部门D,80公司C,部门E,60 要求: 以”,”分割先对第一列字符串升序, 再对第3列数字降序 1sort -t &quot;,&quot; -k1,1 -k3nr,3 sort3.txt 运行效果 小结能够使用sort对字符串升序或降序排序 字符串升序: sort -kstart,end 文件 字符串降序: sort -kstartr,end 文件 能够使用sort 对数字升序或降序 数字升序: sort -kstartn,end 文件 数字降序: sort -kstartnr,end 文件 能够使用sort 对多列进行排序 sort -kstart[nr],end -kstart[nr],end ... 文件 面试题：查空行问题：使用Linux命令查询file.txt中空行所在的行号 file1.txt数据准备 123456itheima itheimaitcast123itheima 答案： 1awk &#x27;/^$/&#123;print NR&#125;&#x27; file1.txt 运行效果 面试题：求一列的和问题：有文件file2.txt内容如下: 123张三 40李四 50王五 60 使用Linux命令计算第二列的和并输出 1awk &#x27;&#123;sum+=$2&#125; END&#123;print &quot;求和: &quot;sum&#125;&#x27; file2.txt 运行效果 面试题：检查文件是否存在问题：Shell脚本里如何检查一个文件是否存在？如果不存在该如何处理？ 答: 1if [ -e /root/file1.txt ]; then echo &quot;文件存在&quot;; else echo &quot;文件不存在&quot;; fi 运行效果 面试题：数字排序问题：用shell写一个脚本，对文本中无序的一列数字排序 cat file3.txt文件内容 1234567891098765432101 答 1sort -n file3.txt | awk &#x27;&#123;sum+=$1; print $1&#125; END&#123;print &quot;求和: &quot;sum&#125;&#x27; 运行效果 面试题：搜索指定目录下文件内容问题：请用shell脚本写出查找当前文件夹（/root）下所有的文本文件内容中包含有字符”123”的文件名称? 答: 1grep -r &quot;123&quot; /root | cut -d &quot;:&quot; -f 1| sort -u 运行效果 面试题：批量生成文件名问题: 批量生产指定数目的文件,文件名采用”纳秒”命名 答: file4.sh 12345678910111213141516#!/bin/bashread -t 30 -p &quot;请输入创建文件的数目:&quot; ntest=$(echo $n | sed &#x27;s/[0-9]//g&#x27;) #检测非数字输入if [ -n &quot;$n&quot; -a -z &quot;$test&quot; ] #检测空输入then for ((i=0;i&lt;$n;i=i+1 )) do name=$(date +%N) [ ! -d ./temp ] &amp;&amp; mkdir -p ./temp touch &quot;./temp/$name&quot; echo &quot;创建 $name 成功!&quot; done else echo &quot;创建失败&quot; exit 1fi 运行效果 面试题：批量改名问题: 将/root/temp目录下所有文件名重命名为”旧文件名-递增数字”? 重命名命令 1rename 旧文件名 新文件名 旧文件所在位置 脚本代码file5.sh 1234567891011#!/bin/bashfilenames=$(ls /root/temp)number=1for name in $filenamesdo printf &quot;命令前:%s&quot; $&#123;name&#125; newname=$&#123;name&#125;&quot;-&quot;$&#123;number&#125; rename $name $&#123;newname&#125; /root/temp/* let number++ #每个改名后的文件名后缀数字加1 printf &quot;重命名后:%s \\n&quot; $&#123;newname&#125;done 运行效果 面试题：批量创建用户问题: 根据users.txt中提供的用户列表,一个名一行, 批量添加用户到linux系统中 已知users.txt数据准备 12user1user2 知识点分析1: 添加用户命令 1useradd 用户名 知识点分析2: 设置每个用户密码默认密码 1echo &quot;123456&quot; | passwd --stdin 用户名 运行效果 面试题答案: 脚本代码file6.sh 12345678#!/bin/bashULIST=$(cat /root/users.txt) ##/root/users.txt 里面存放的是用户名，一个名一行for UNAME in $ULISTdo useradd $UNAME echo &quot;123456&quot; | passwd --stdin $UNAME &amp;&gt;/dev/null [ $? -eq 0 ] &amp;&amp; echo &quot;$UNAME用户名与密码添加初始化成功!&quot;done 运行效果 面试题：筛选单词问题: 根据给出的数据输出里面单词长度大于3的单词 数据准备 1I may not be able to change the past, but I can learn from it. shell脚本file7.sh 1echo &quot;I may not be able to change the past, but I can learn from it.&quot; | awk -F &quot;[ ,.]&quot; &#x27;&#123;for(i=1;i&lt;NF;i++)&#123; if(length($i)&gt;3)&#123;print $i&#125;&#125;&#125;&#x27; 运行效果 面试题：单词及字母去重排序问题 121、按单词出现频率降序排序！2、按字母出现频率降序排序！ file8.txt 文件内容 1No. The Bible says Jesus had compassion2 on them for He saw them as sheep without a shepherd. They were like lost sheep, lost in their sin. How the Lord Jesus loved them! He knew they were helpless and needed a shepherd. And the Good Shepherd knew He had come to help them. But not just the people way back then. For the Lord Jesus knows all about you, and loves you too, and wants to help you. 按照单词出现频率降序 1awk -F &quot;[,. ]+&quot; &#x27;&#123;for(i=1;i&lt;=NF;i++)S[$i]++&#125;END&#123;for(key in S)print S[key],key&#125;&#x27; file8.txt |sort -rn|head 运行效果 按照字符出现频率降序前10个 1awk -F &quot;&quot; &#x27;&#123;for(i=1;i&lt;=NF;i++)S[$i]++&#125;END&#123;for(key in S)print S[key],key&#125;&#x27; file8.txt |sort -rn|head 运行效果 面试题：扫描网络内存活主机问题: 扫描192.168.56.1到192.168.56.254之间ip的是否存活, 并输出是否在线? 服务器ip存活分析 12ping ip地址 -c 2# 如果ip地址存活发送2个数据包会至少接收返回1个数据包 效果如图 完整脚本代码 1234567891011121314151617#!/bin/bashcount=0for i in 192.168.56.&#123;1..254&#125;do # 使用ping命令发送2个包测试, 并获取返回接收到包的个数 receive=$(ping $i -c 2|awk &#x27;NR==6&#123;print $4&#125;&#x27;) # 接收返回包大于0 说明主机在线 if [ $&#123;receive&#125; -gt 0 ] then echo &quot;$&#123;i&#125; 在线&quot; ((count+=1)) else echo &quot;$&#123;i&#125; 不在线&quot; fidoneecho &quot;在线服务器有:&quot;$count&quot;个&quot; 运行效果 面试题：MySQL分库备份123456789101112131415161718#!/bin/shuser=root #用户名pass=root #密码backfile=/root/mysql/backup #备份路径[ ! -d $backfile ] &amp;&amp; mkdir -p $backfile #判断是否有备份路径cmd=&quot;mysql -u$user -p$pass&quot; #登录数据库dump=&quot;mysqldump -u$user -p$pass &quot; #mysqldump备份参数dblist=`$cmd -e &quot;show databases;&quot; 2&gt;/dev/null |sed 1d|egrep -v &quot;_schema|mysql&quot;` #获取库名列表echo &quot;需要备份的数据列表:&quot;echo $dblistecho &quot;开始备份:&quot;for db_name in $dblist #for循环备份库列表do printf &#x27;正在备份数据库:%s&#x27; $&#123;db_name&#125; $dump $db_name 2&gt;/dev/null |gzip &gt;$&#123;backfile&#125;/$&#123;db_name&#125;_$(date +%m%d).sql.gz #库名+时间备份打包至指定路径下 printf &#x27;,备份完成\\n&#x27;doneecho &quot;全部备份完成!!!&quot; 运行效果 面试题：MySQL数据库分库分表备份1234567891011121314151617181920212223242526#!/bin/shuser=root #用户名pass=root #密码backfile=/root/mysql/backup #备份路径[ ! -d $backfile ] &amp;&amp; mkdir -p $backfile #判断是否有备份路径cmd=&quot;mysql -u$user -p$pass&quot; #登录数据库dump=&quot;mysqldump -u$user -p$pass &quot; #mysqldump备份参数dblist=`$cmd -e &quot;show databases;&quot; 2&gt;/dev/null |sed 1d|egrep -v &quot;_schema|mysql&quot;` #获取库名列表echo &quot;需要备份的数据列表:&quot;echo $dblistecho &quot;开始备份:&quot;for db_name in $dblist #for循环备份库列表do printf &#x27;正在备份数据库:%s\\n&#x27; $&#123;db_name&#125; tables=`mysql -u$user -p&quot;$pass&quot; -e &quot;use $db_name;show tables;&quot; 2&gt;/dev/null|sed 1d` for j in $tables do printf &#x27;正在备份数据库 %s 表 %s &#x27; $&#123;db_name&#125; $&#123;j&#125; $dump -B --databases $db_name --tables $j 2&gt;/dev/null &gt; $&#123;backfile&#125;/$&#123;db_name&#125;-$&#123;j&#125;-`date +%m%d`.sql printf &#x27;,备份完成\\n&#x27; done printf &#x27;数据库 %s 备份完成\\n&#x27; $&#123;db_name&#125;doneecho &quot;全部备份完成!!!&quot; 运行效果","categories":[{"name":"运维","slug":"运维","permalink":"http://liujun1997.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Linux Shell","slug":"Linux-Shell","permalink":"http://liujun1997.github.io/tags/Linux-Shell/"}]},{"title":"Shell-3","slug":"Shell-3","date":"2021-09-04T11:39:55.000Z","updated":"2022-04-23T12:25:27.941Z","comments":true,"path":"2021/09/04/Shell-3/","link":"","permalink":"http://liujun1997.github.io/2021/09/04/Shell-3/","excerpt":"","text":"Shell计算命令：expr命令详解介绍expr (evaluate expressions 的缩写)，译为“表达式求值”。Shell expr 是一个功能强大，并且比较复杂的命令，它除了可以实现整数计算，还可以结合一些选项对字符串进行处理，例如计算字符串长度、字符串比较、字符串匹配、字符串提取等. 求值表达式(已讲)计算语法 123expr 算术运算符表达式# 例如: expr 1 + 1 返回: 2# 例如: expr \\( 10 + 10 \\) \\* 2 + 100 返回:140 获取计算结果赋值给新变量语法 12result=`expr 算术运算符表达式`# 例如: result=`expr 1 + 1` 输出result得到结果: 2 字符串语法计算字符串的长度语法 12expr length 字符串# 例如: expr length &quot;itheima&quot; 返回: 7 截取字符串语法 1234expr substr 字符串 start end# start 截取字符串的起始位置, 从1开始# end 截取字符串的结束位置, 包含这个位置截取# 例如 expr substr &quot;itheima&quot; 1 2 返回: it 获取第一个字符在字符串中出现的位置语法 12expr index 被查找字符串 需要查找的字符# 例如 expr index &quot;itheima&quot; t 会返回: 2 正则表达式匹配1语法 1234567expr match 字符串 正则表达式# 正则表达式默认带有^ , 代表以什么开头# 返回值为符合匹配字符的长度, 否则返回为0# 例如: expr match &quot;itheima&quot; &quot;.*m&quot; 会返回: 6# 正则表达式通配符&quot;.&quot;代表任意一个字符# 正则表达式通配符&quot;*&quot;代表签名的字符可以出现0到多次# &quot;.*m&quot; 含义为匹配字符串中m前面的字符串长度 正则表表达式匹配2语法, 功能与语法1一样 1234expr 字符串 : 正则表达式# 正则表达式默认带有^ , 代表以什么开头# 返回值为符合匹配字符的长度, 否则返回为0# 例如: expr &quot;itheima&quot; : &quot;.*m&quot; 会返回: 6 演示需求 1234# 四则运算: ( 10 + 10 ) * 2 + 100# 计算&quot;itheima&quot;字符串的长度# 获取&quot;itheima&quot;字符串中&quot;t&quot;第一个字符在字符串中出现的位置# 正则表达式match匹配查找itheima字符串中m前面任意字符的总长度 cal1.sh脚本文件代码 12345678910111213141516#!/bin/bash# 四则运算result=`expr \\( 10 + 10 \\) \\* 2 + 100`echo &quot;(10+10)*2+100=$&#123;result&#125;&quot;# 计算字符串的长度echo &quot;itheima字符串长度=`expr length &quot;itheima&quot;`&quot;# 获取第一个字符在字符串中出现的位置echo &quot;itheima字符串中第一个t的位置=`expr index &quot;itheima&quot; t`&quot;# 正则表达式匹配1echo &quot;正则表达式match匹配查找itheima字符串中m前面任意字符的总长度=`expr match &quot;itheima&quot; &quot;.*m&quot;`&quot;# 正则表达式匹配2echo &quot;正则表达式匹配查找itheima字符串中m前面任意字符的总长度=`expr &quot;itheima&quot; : &quot;.*m&quot;`&quot; 运行效果 小结expr命令的作用 整数计算 expr 整数运算表达式 字符串操作 expr length 字符串 获取字符串的长度 expr substr 字符串 start end 截取字符串 expr index 字符串 查找的字符 查找字符在字符串中第一次出现的位置, 位置从1开始的 expr match 字符串 正则表达式 expr 字符串: 正则表达式 Shell计算命令：(())命令详解目标能够使用(())进行整数的数学运算 介绍双小括号 (( )) , 用于进行数学运算表达式的执行 , 将数学运算表达式放在((和))之间。 可以使用$获取 (( )) 表达式命令的结果，这和使用$获得变量值是一样的。 语法1((表达式)) 用法 运算操作符/运算命令 说明 ((a=1+6)) ((b=a-1)) ((c=a+b)) 这种写法可以在计算完成后给变量赋值。以 ((b=a-1)) 为例，即将 a-1 的运算结果赋值给变量 c。 注意，使用变量时不用加$前缀，(( )) 会自动解析变量名。 a=$((1+6) b=$((a-1)) c=$((a+b)) 可以在 (( )) 前面加上$符号获取 (( )) 命令的执行结果，也即获取整个表达式的值。以 c=$((a+b)) 为例，即将 a+b 这个表达式的运算结果赋值给变量 c。 注意，如果 c=((a+b)) 这样的写法是错误的，不加$就不能取得表达式的结果。 ((a&gt;7 &amp;&amp; b==c)) (( )) 也可以进行逻辑运算，在 if 语句中常会使用逻辑运算。 echo $((a+10)) 需要立即输出表达式的运算结果时，可以在 (( )) 前面加$符号。 ((a=3+5, b=a+10)) 对多个表达式同时进行计算, 多表表达式使用”,”号隔开 注意: 符号之间有无空格都可以 , (( a = 1 + 6 )) 等价于 ((a=1+6)) 示例需求 123456789101112131415# 计算1+6赋值给变量a# 计算变量a-1赋值给变量b# 计算变量a+变量b赋值给变量c# 打印变量a,变量b, 变量c的值# $赋值写法# (())多个表达式计算赋值# echo输出直接使用(())# (()) 用于逻辑表达式 在if中使用 calculatej2.sh脚本代码 12345678910111213141516171819202122232425262728293031#!/bin/bash# 计算1+6赋值给变量a((a=1+6))# 计算变量a-1赋值给变量b((b=a-1))# 计算变量a+变量b赋值给变量c((c=a+b))# 打印变量a,变量b, 变量c的值echo &quot;a=$&#123;a&#125;,b=$&#123;b&#125;,c=$&#123;c&#125;&quot;# $赋值写法a=$((1+6)) b=$((a-1)) c=$((a+b))echo &quot;a=$&#123;a&#125;,b=$&#123;b&#125;,c=$&#123;c&#125;&quot;# (())多个表达式计算赋值((a=1+6,b=a-1,c=a+b))echo &quot;a=$&#123;a&#125;,b=$&#123;b&#125;,c=$&#123;c&#125;&quot;# echo输出直接使用(())echo &quot;1+6=$((1+6))&quot;# (()) 用于逻辑表达式 在if中使用if ((a&gt;7 &amp;&amp; b==c))then echo &quot;a&gt;7 &amp;&amp; b==c 成立&quot;else echo &quot;a&gt;7 &amp;&amp; b==c 不成立&quot;fi 运行结果 小结(())的用法 括号内赋值: ((变量名=整数表达式)) 括号外赋值: 变量名=$((整数表达式)) 多表达式赋值: ((变量名1=整数表达式1,变量名2=整数表达式2,…)) 与if条件句配合使用: if ((整数表达式)) Shell计算命令：let命令详解目标能够使用let进行整数的数学运算赋值 介绍let 命令和双小括号 (( )) 在数字计算方面功能一样. 但是没有(())功能强大, let只能用于赋值计算, 不能直接输出, 不可以条件判断一起使用 语法1let 赋值表达式 注意 语法功能等价于((表达式)) 多个表达式之间使用空格, 不是”,”号 对于类似let a+b这样的写法，Shell 虽然计算了 a+b 的值，但却将结果丢弃, 如果 echo let a+b 会直接输出字符串 a+b ；若不想这样，可以使用let sum=a+b将 a+b 的结果保存在变量 sum 中。 输出建议使用(()) 示例需求 1234# 计算变量a-1赋值给变量b# 计算变量a+变量b赋值给变量c# 打印变量a,变量b, 变量c的值# let多个表达式计算赋值 calculate3.sh脚本代码 12345678910111213141516#!/bin/bash# 计算1+6赋值给变量alet a=1+6# 计算变量a-1赋值给变量blet b=a-1# 计算变量a+变量b赋值给变量clet c=a+b# 打印变量a,变量b, 变量c的值echo &quot;a=$&#123;a&#125;,b=$&#123;b&#125;,c=$&#123;c&#125;&quot;# let多个表达式计算赋值let a=1+6 b=a-1 c=a+becho &quot;a=$&#123;a&#125;,b=$&#123;b&#125;,c=$&#123;c&#125;&quot; 运行效果 小结let数字计算用法 作用: 用于赋值,是最简洁的整数运算赋值命令 计算赋值用法: let 变量名=整数运算表达式 多个表达式计算赋值用法: let 变量名1=整数运算表达式1 变量名2=整数运算表达式2 … Shell计算命令：$[]命令详解目标能够使用$[]进行整数的数学运算 介绍和 (())、let 命令类似，$[] 也只能进行整数运算。但是只能对单个表达式的计算求值与输出 语法1$[表达式] $[] 会对表达式进行计算，并取得计算结果 表达式内部不可以赋值给变量 示例calculate4.sh脚本代码 123456789101112131415#!/bin/bash# 计算1+6赋值给变量aa=$[1+6]# 计算变量a-1赋值给变量bb=$[a-1]# 计算变量a+变量b赋值给变量cc=$[a+b]# 打印变量a,变量b, 变量c的值echo &quot;a=$&#123;a&#125;,b=$&#123;b&#125;,c=$&#123;c&#125;&quot;# 直接输出echo &quot;$[1+6],$[7-1],$[7+6]&quot; 运行结果 小结执行整数表达式命令的总结, 推荐使用哪个 expr ​ 优点: 可以直接输出 ​ 缺点: 计算表达式里面引用变量使用$, 特殊字符需要转义 只能计算一个表达式 (()) (直接求值输出推荐方式) ​ 优点: 直接输出, 里面直接使用变量名, 特殊字符不需要转义, 多个表达式赋值 ​ 缺点: 需要获取值以后才可以输出 let (赋值推荐方式) ​ 优点: 赋值简单,特殊字符不需要转义, ​ 缺点: 不能直接输出 $[] ​ 优点: ,特殊字符不需要转义, ​ 缺点: 不能多表达是计算, Shell计算命令：bc命令详解目标理解bc命令的作用 能够在bc中进行互动式的数学运算 能够在shell中进行非互动式的bc管道运算 能够在shell中非互动式的输入重定向bc运算 介绍Bash shell内置了对整数运算的支持，但是并不支持浮点运算，而 linux bc (basic calculator)命令可以很方便的进行浮点运算. bc命令是Linux简单的计算器,能进行进制转换与计算。能转换的进制包括十六进制、十进制、八进制、二进制等。可以使用的运算符号包括(+)加法、(-)减法、(*)乘法、(/)除法、(^)指数、(%)余数等 bc命令语法1bc [options] [参数] options 选项 说明 -h help，帮助信息 -v version，显示命令版本信息 ==-l== mathlib, 使用标准数学库, 例如使用内置函数就需要使用这个参数 -i interactive, 强制交互 -w warn, 显示 POSIX 的警告信息 -s standard, 使用 POSIX 标准来处理 ==-q== quiet, 不显示欢迎信息 默认使用bc命令后回车会有很多欢迎信息， 可以使用 bc -q 回车后不会有欢迎信息 参数文件： 指定包含计算任务的文件。 示例：bc执行计算任务的文件创建task.txt文件, 编辑文件内容(一个计算表达式一行) 12108*67+1234558+2007*11 执行命令 可以使用 quit 命令退出bc 内置变量 变量名 作 用 scale 指定精度，也即小数点后的位数, 对计算结果指定保留小数；默认为 0，也即不使用小数部分。 ibase 指定输入的数字的进制，默认为十进制。 obase 指定输出的数字的进制，默认为十进制。 last 或者 . 获取最近计算打印结果的数字 内置数学函数 函数名 作用 s(x) 计算 x 的正弦值，x 是弧度值。 c(x) 计算 x 的余弦值，x 是弧度值。 a(x) 计算 x 的反正切值，返回弧度值。 l(x) 计算 x 的自然对数。 e(x) 求 e 的 x 次方。 j(n, x) 贝塞尔函数，计算从 n 到 x 的阶数。 作用通常在linux下bc当计算器用, 具体有3个用法 bc中互动式的数学运算 shell中非互动式的管道运算 shell中非互动式的输入重定向运算 示例：bc中互动式的数学运算介绍使用 bc -q 命令，回车即可, 直接进行计算器进行运算 演示 退出bc使用 quit 示例：shell中非互动式的管道运算介绍在 Shell 脚本中，我们可以借助管道使用 bc 计算器。 借助管道使用 bc 计算器语法直接进行bc的表达式计算输出 1echo &quot;expression&quot; | bc [options] “expression” 表达式必须复合bc命令要求的公式 “expression” 表达式里面可以引用shell变量 例如: Shell变量 a=2 在表达式里面引用的语法: $a 将bc计算结果赋值给Shell变量 12345# 第一种方式var_name=`echo &quot;expression&quot; | bc [options]`# 第二种方式var_name=$(echo &quot;expression&quot; | bc [options]) $() 与 `` 功能一样, 都是执行里面的命令 区别 ​ `` 是所有linux系统支持的方式, 兼容性较好, 但是容易与引号产生混淆 ​ $() 不是所有linux系统都支持的方式, 兼容性较差, 但是不容易产生混淆 演示 引用shell变量进行计算 注意 b是bc中定义的新变量, 与shell变量没有任何关系, 所以不可以在shell中获取b变量 进制转换 示例：shell中非互动式的输入重定向运算介绍将计算表达式输出给bc去执行, 特点类似于文件中输入,可以输入多行表达式, 更加清晰 语法123456789101112131415# 第一种方式var_name=`bc [options] &lt;&lt; EOF第一行表达式1第二行表达式2...EOF`# 第二种方式var_name=$(bc [options] &lt;&lt; EOF第一行表达式1第二行表达式2...EOF) var_name 这是Shell变量的名字 bc 执行bc的命令 EOF..EOF 输入流的多行表达式 含义: 将EOF中间多行表达式输入给到bc去执行, j将bc执行的结果给到Shell变量var_name 演示 如果有大量的数学计算，那么使用输入重定向就比较方便，因为数学表达式可以换行，写起来更加清晰。 小结bc命令的作用 是一个任意精度计算器 在bc中进行互动式的数学运算 bc -q 进入bc环境 直接输入一个算术表达式后回车 bc就会计算出结果输出 在shell中进行非互动式的bc管道运算 直接输出结果: echo “bc表达式” |bc [options]赋值给变量: 变量名=$(echo “bc表达式” |bc [options]) 在shell中非互动式的输入重定向bc运算 变量名=$(bc &lt;&lt; EOF bc表达式 EOF ) 适合大量计算表达式 流程控制：if else语句目标能够使用if条件语句进行条件判断 介绍if条件判断逻辑控制语句 if语法多行写法语法 1234if 条件then 命令fi 可以将if语句放入一行语法 1if 条件; then 命令; fi if else 语法123456if 条件then 命令else 命令fi if elif else 语法12345678910111213if 条件1then 命令1elif 条件2then 命令2elif 条件3then 命令3……else 命令Nfi 演示需求 123456提示&quot;请输入你的考试成绩:&quot; 接收用户输入一个成绩, 之后使用if else条件句判断要求1: 小于 60 输出&quot;不及格&quot;要求2: 大于等于70 并且 小于80 输出&quot;中等&quot;要求3: 大于等于80 并且 小于90 输出&quot;良好&quot;要求4: 大于等于90 并且 小于等于100 输出&quot;优秀&quot;要求5: 以上不符合输出&quot;成绩不合法&quot; control1.sh脚本代码 123456789101112131415#!/bin/bashread -p &quot;请输入你的考试成绩:&quot; scoreif (( $score &lt; 60 )); then echo &quot;不及格&quot;elif (( $score &gt;= 60 &amp;&amp; $score &lt; 70 )); then echo &quot;及格&quot;elif (( $score &gt;= 70 &amp;&amp; $score &lt; 80 )); then echo &quot;中等&quot;elif (( $score &gt;= 80 &amp;&amp; $score &lt; 90 )); then echo &quot;良好&quot;elif (( $score &gt;= 90 &amp;&amp; $score &lt;= 100 )); then echo &quot;优秀&quot;else echo &quot;成绩不合法&quot;fi (())是一种数学计算命令，它除了可以进行最基本的加减乘除运算，还可以进行大于、小于、等于等关系运算，以及与、或、非逻辑运算。当 a 和 b 相等时，(( $a == $b ))判断条件成立，进入 if，执行 then 后边的 echo 语句 运行效果 小结使用if条件语句进行条件判断 12345678910111213if 条件1 then 命令1elif 条件2 then 命令2elif 条件3 then 命令3...else 命令nfi if条件判断句的退出状态目标 理解什么是退出状态 能够查询每个命令的退出状态 介绍linux任何命令的的执行都会有一个退出状态, 无论是内置命令还是外部文件命令. 还是自定义的 Shell 函数，当它退出（运行结束）时，都会返回一个比较小的整数值给调用（使用）它的程序，这就是命令的退出状态 大多数命令状态0代表成功, 非0代表失败. 也有特殊的命令,比如 diff 命令用来比较两个文件的不同，对于“没有差别”的文件返回 0，对于“找到差别”的文件返回 1，对无效文件名返回 2 Shell 中，有多种方式取得命令的退出状态，其中 $? 是最常见的一种. 演示 退出状态和逻辑运算符的组合Shell if 语句使用逻辑运算符将多个退出状态组合起来，这样就可以一次判断多个条件了。 运算符 使用格式 说明 &amp;&amp; 或 -a 条件1 &amp;&amp; 条件2 逻辑与运算符，当 条件1 和 条件2 同时成立时，整个表达式才成立。 如果检测到 条件1 的退出状态为 0，就不会再检测 条件2 了，因为不管 条件2 的退出状态是什么，整个表达式必然都是不成立的，检测了也是多此一举。 || 或 -o 条件1 || 条件2 逻辑或运算符，条件1 和 条件2 两个表达式中只要有一个成立，整个表达式就成立。 如果检测到 条件1 的退出状态为 1，就不会再检测 条件2 了，因为不管 条件2 的退出状态是什么，整个表达式必然都是成立的，检测了也是多此一举。 ! !条件 逻辑非运算符，相当于“取反”的效果。如果 条件 成立，那么整个表达式就不成立；如果 条件 不成立，那么整个表达式就成立。 示例需求提示输入”请输入文件全名: “和”请输入数据:” 并接收文件名与数据 使用逻辑运算符判断满足2 条件 : 文件需要具有可写权限 和 输入的数据长度不为0 满足以上2个条件 将用户输入的 数据 写入到指定的文件中去 演示创建itheima.txt 1touch itheima.txt control2.sh脚本文件代码 1234567891011#!/bin/bashread -p &quot;请输入文件全名: &quot; filenameread -p &quot;请输入数据:&quot; dataif [ -w $filename -a -n $data ]then echo $data echo $data &gt; $filename echo &quot;成功&quot;else echo &quot;失败&quot;fi test命令用于对文件或字符串进行检测, -w 判断文件是否存在并且可写, -n 用于检测字符串是否非空, 后续讲解. $data &gt; $filename 其中 &gt; 用于将内容输出到指定文件中去 运行结果 小结 什么是退出状态 每个命令运行后都会返回一个退出状态值, 大多数返回0代表成功, 非0 代表失败 查询每个命令的退出状态 常见命令 $? Shell内置命令：test目标 理解test命令对整数比较测试 理解test命令对字符串 能够使用test命令对文件测试 介绍Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。 功能与[]一样 整数比较测试语法1234if test 数字1 options 数字2 then ...fi options具体如下 参数 说明 -eq 等于则为真 -ne 不等于则为真 -gt 大于则为真 -ge 大于等于则为真 -lt 小于则为真 -le 小于等于则为真 演示control3.sh脚本代码 1234567891011121314151617#!/bin/bashnum1=1 num2=1 num3=2echo &quot;num1=$&#123;num1&#125;,num2=$&#123;num2&#125;,num3=$&#123;num3&#125;&quot;if test $num1 -eq $num2then echo &#x27;num1和num2两个数相等！&#x27;else echo &#x27;num1和num2两个数不相等！&#x27;fiif test $num2 -eq $num3then echo &#x27;num2和num3两个数相等！&#x27;else echo &#x27;num2和num3两个数不相等！&#x27;fi 运行效果 字符串比较测试语法 参数 说明 = 或 == 等于, 等于返回0代表成功,否则返回1代表失败 != 不等于 \\&lt; 小于 \\&gt; 大于 -z 字符串 字符串的长度为零则为真 -n 字符串 字符串的长度不为零则为真 演示control4.sh脚本代码 1234567891011121314151617181920212223242526272829303132#!/bin/bashstr1=&quot;itheima&quot; str2=&quot;itcast&quot; str3=&quot;&quot;echo &quot;str1=$&#123;str1&#125;,str2=$&#123;str2&#125;,str3=$&#123;str3&#125;&quot;if test $str1 = $str2then echo &#x27;str1和str2两个字符串相等&#x27;else echo &#x27;str1和str2两个字符串不相等&#x27;fiif test $str1 \\&gt; $str2then echo &#x27;str1大于str2&#x27;else echo &#x27;str1小于str2&#x27;fiif test -z $str2then echo &quot;str2字符串长度为0&quot;else echo &quot;str2字符串长度不为0&quot;fiif test -z $str3then echo &quot;str3字符串长度为0&quot;else echo &quot;str3字符串长度不为0&quot;fi 运行效果 文件测试语法 参数 说明 ==-e 文件名== exists, 如果文件存在则为真 ==-r 文件名== read,如果文件存在且可读则为真 ==-w 文件名== write,如果文件存在且可写则为真 ==-x 文件名== execute,如果文件存在且可执行则为真 ==-s 文件名== string,如果文件存在且至少有一个字符则为真 ==-d 文件名== directory,如果文件存在且为目录则为真 -f 文件名 file,如果文件存在且为普通文件则为真 -c 文件名 character,如果文件存在且为字符型特殊文件则为真 -b 文件名 如果文件存在且为块特殊文件则为真 演示查询control1.sh与control2.sh文件 control5.sh脚本代码 123456789101112131415#!/bin/bashif test -w ./control1.shthen echo &#x27;文件已存在并且可写!&#x27;else echo &#x27;文件不存在或不可写!&#x27;fiif test -e ./control1.sh -a -e ./control2.shthen echo &#x27;两个文件都存在!&#x27;else echo &#x27;可能有一个或两个文件不存在&#x27;fi Shell提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：”!”最高，”-a”次之，”-o”最低, 语法 1test 条件1 -o 条件2 -a 条件3 ... 运行效果 小结 test命令对整数比较测试 test 整数1 options 整数2 options: lt le gt ge eq ne test命令对字符串比较测试 test 变量1 options 变量2 options: &gt; &lt; != = == &lt; &gt; 需要转义 使用test命令对文件测试 test options 文件路径字符串 options: -w -r -e -x -s -d ​ 注意: test命令与[] 功能一样 流程控制：case语句目标理解使用case多分支条件判断 介绍Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令; 当分支较多，并且判断条件比较简单时，使用 case in 语句就比较方便了。 语法1234567891011121314151617case 值 in匹配模式1) 命令1 命令2 ... ;;匹配模式2） 命令1 命令2 ... ;;*) 命令1 命令2 ... ;;esac 每一匹配模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;(类似break, 不可以替代否则语法报错)。取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。 case、in 和 esac 都是 Shell 关键字, esac就是case的反写在这里代表结束case 匹配模式: 可以是一个数字、一个字符串，甚至是一个简单正则表达式。 简单正则表达式支持如下通配符 格式 说明 * 表示任意字符串。 [abc] 表示 a、b、c 三个字符中的任意一个。比如，[15ZH] 表示 1、5、Z、H 四个字符中的任意一个。 [m-n] 表示从 m 到 n 的任意一个字符。比如，[0-9] 表示任意一个数字，[0-9a-zA-Z] 表示字母或数字。 | 表示多重选择，类似逻辑运算中的或运算。比如，abc | xyz 表示匹配字符串 “abc” 或者 “xyz”。 演示control6.sh脚本代码 12345678910111213141516171819202122232425262728#!/bin/bashread -p &quot;请输入一个0~7的数字:&quot; numbercase $number in1) echo &quot;星期一&quot; ;;2) echo &quot;星期二&quot; ;;3) echo &quot;星期三&quot; ;;4) echo &quot;星期四&quot; ;;5) echo &quot;星期五&quot; ;;6) echo &quot;星期六&quot; ;;0|7) echo &quot;星期日&quot; ;;*) echo &quot;您输入的数字无效&quot; ;; esac 运行效果 小结使用case多分支条件判断语法 123456789101112131415case 表达式 in模式1) 命令 ... ;;模式2) 命令 ... ;;...*) 命令 ... ;; 流程控制：while语句目标理解whlie循环的使用 介绍while用于循环执行一系列命令 语法多行写法 12345678while 条件do 命令1 命令2 ... continue; # 结束当前这一次循环, 进入下一次循环 break; # 结束当前循环done 一行写法 1while 条件; do 命令; done; 演示control7.sh脚本文件代码: 输出指定多少次的hello world 12345678#!/bin/bashread -p &quot;请输入一个数字:&quot; numberi=0while [[ $i &lt; $number ]]do echo &quot;hello world&quot; ((i++))done 运行效果 无限循环1234while :do commanddone 或 1234while truedo commanddone 小结whlie循环的使用语法 while 条件 do ​ 命令 done 流程控制：until语句目标理解until循环结构的使用 介绍until 也是循环结构语句, until 循环与 while 循环在处理方式上刚好相反, 循环条件为false会一致循环, 条件为true停止循环. 语法1234until 条件do 命令done 条件如果返回值为1(代表false)，则继续执行循环体内的语句，否则跳出循环。 演示control8.sh脚本代码 12345678#!/bin/bashread -p &quot;请输入一个数字:&quot; numberi=0until [[ ! $i &lt; $number ]]do echo &quot;hello world&quot; ((i++))done 运行效果 小结until循环结构的使用语法 until 条件 do ​ 命令 done 条件为false继续循环, 为true停止循环 流程控制：for语句目标能够使用for进行循环操作 介绍Shell支持for循环, 与其他编程语言类似. 循环方式1语法多行写法 123456for var in item1 item2 ... itemNdo 命令1 命令2 ...done 一行写法 1for var in item1 item2 ... itemN; do 命令1; 命令2…; done; var是循环变量 item1 item2 … itemN 是循环的范围 演示control9.sh脚本代码 12345#!/bin/bashfor i in 1 2 3 4 5do echo &quot;hello world&quot;done 运行效果 循环方式2语法多行写法 1234for var in &#123;start..end&#125;do 命令done start: 循环范围的起始值,必须为整数 end: 循环范围的结束值, 必须为整数 一行写法 1for var in &#123;start..end&#125;; do 命令; done 演示循环1到5并打印 1for i in &#123;1..5&#125;; do echo $i; done 效果 循环方式3语法多行写法 1234for((i=start;i&lt;=end;i++))do 命令done 一行写法 1for((i=start;i&lt;=end;i++)); do 命令; done 演示 无限循环1for((;;)); do 命令; done 小结使用for进行循环操作的3种方式 方式1: for i in item1 item2 ...; do 命令; done 方式2: for i in &#123;start..end&#125;; do 命令; done 方式3: for((i=start;i&lt;=end;i++)); do 命令; done 流程控制：select语句目标能够使用select语句进行菜单选择输入 介绍select in 循环用来增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能. select in 是 Shell 独有的一种循环，非常适合终端（Terminal）这样的交互场景, 其他语言没有; 语法1234select var in menu1 menu2 ...do 命令done 注意: select 是无限循环（死循环），输入空值，或者输入的值无效，都不会结束循环，只有遇到 break 语句，或者按下 Ctrl+D 组合键才能结束循环。 执行命令过程中: 终端会输出 #? 代表可以输入选择的菜单编号 演示1脚本代码 12345678#!/bin/bashecho &quot;你的爱好是什么?&quot;select hobby in &quot;编程&quot; &quot;游戏&quot; &quot;篮球&quot; &quot;游泳&quot;do echo $hobby breakdoneecho &quot;你的爱好是:$&#123;hobby&#125;&quot; 运行效果 演示2脚本文件代码 123456789101112131415161718192021#!/bin/bashecho &quot;你的爱好是什么&quot;select hobby in &quot;编程&quot; &quot;游戏&quot; &quot;篮球&quot; &quot;游泳&quot;do case $hobby in &quot;编程&quot;) echo &quot;编程,多敲代码&quot; break ;; &quot;游戏&quot;) echo &quot;少玩游戏&quot; break ;; &quot;篮球&quot;|&quot;游泳&quot;) echo &quot;运动有利健康&quot; break ;; *) echo &quot;输入错误，请重新输入&quot; esacdone 运行效果 小结select的作用 用于交互式循环输入选择菜单 常与 case in 一起配合使用 Shell函数：系统函数目标 理解函数的分类 理解常用的系统函数 函数介绍Shell编程和其他编程语言一样, 有函数, 函数是由若干条shell命令组成的语句块，实现Shell脚本代码重用和模块化编程。 函数分类 系统函数 自定义函数 系统函数介绍系统自带提供的函数, 可以直接使用. basename系统函数介绍basename函数用于获取文件名的函数, 根据给出的文件路径截取出文件名 语法1basename [string / pathname] [suffix] 根据根据指定字符串或路径名进行截取文件名, 比如: 根据路径”/one/two/aa.txt”, 可以截取出aa.txt suffix: 用于截取的时候去掉指定的后缀名. 演示 dirname系统函数介绍从指定的文件绝对路径, 去除文件名，返回剩下的前缀目录路径 语法1dirname 文件绝对路径 演示 小结 函数的分类 系统函数 自定义函数 常用的系统函数 basename 用于从指定路径中获取文件名 dirname 用于从指定的路径中获取目录名, 去掉文件名 Shell函数：自定义函数目标 能够使用Shell的自定义函数实现代码重用 能够说出Shell程序命令与函数的区别 介绍开发人员可以通过自定义开发函数,实现代码重用. 语法12345678910# 函数的定义[ function ] funname ()&#123; 命令 [return 返回值]&#125;# 调用函数funname 传递参数1 传递参数2 ... 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0~255) 注意必须在调用函数地方之前，先声明函数，shell脚本是逐行运行, 只要先运行了函数, 后面才可以时使用函数 示例：无参无返回值函数文件脚本代码 12345678#!/bin/bashdemo()&#123; echo &quot;执行了函数&quot;&#125;# 调用函数demo 运行效果 示例：无参有返回值函数fun2.sh文件脚本代码 12345678910111213#!/bin/bashsum()&#123; echo &quot;求两个数的和...&quot; read -p &quot;输入第一个数字: &quot; n1 read -p &quot;输入第二个数字: &quot; n2 echo &quot;两个数字分别为 $n1 和 $n2 &quot; return $(($n1+$n2))&#125;# 调用函数sumecho &quot;两个数字的和为: $? &quot; # 获取函数返回值 运行效果 示例：有参函数介绍在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1 表示第一个参数，$2 表示第二个参数… 其他参数介绍 参数处理 说明 $# 传递到脚本或函数的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 演示fun3.sh文件脚本代码 123456789101112#!/bin/bashfunParam()&#123; echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 $&#123;10&#125; !&quot; echo &quot;第十一个参数为 $&#123;11&#125; !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;# 调用函数funParam 1 2 3 4 5 6 7 8 9 10 22 运行效果 Shell程序与函数的区别区别函数和shell程序比较相似，区别在于： Shell 程序(内置命令和外部脚本文件), 外部脚本文件是在子Shell中运行, 会开启独立的进程运行 Shell函数在当前Shell的进程中运行 演示fun4.sh脚本文件代码 12345678#!/bin/bashdemo()&#123; echo &quot;函数中打印当前进程ID:$$&quot;&#125;echo &quot;当前脚本文件(Shell程序)打印当前进程ID:$$&quot;# 调用函数demo 运行效果 小结 使用Shell的自定义函数实现代码重用 12345函数名()&#123; 命令 # 使用$n获取函数的参数 [return 返回值]&#125; 说出Shell程序命令与函数的区别 Shell程序命令: 运行命令时开启一个子进程运行命令 函数: 在当前Shell环境中运行, 没有开启进程 Shell重定向输入输出目标 理解Shell重定向的含义 能够使用重定向输出数据到文件中保存 能够使用重定向从文件中读取输入数据 重定向介绍标准输入介绍从键盘读取用户输入的数据，然后再把数据拿到Shell程序中使用； 标准输出介绍Shell程序产生的数据，这些数据一般都是呈现到显示器上供用户浏览查看; 默认输入输出文件每个 Unix/Linux 命令运行时都会打开三个文件, 文件如下 文件名 类型 文件描述符(file description, fd) 功能 stdin (standard input)标准输入文件 0 获取键盘的输入数据 stdout (standard output)标准输出文件 1 将正确数据输出到显示器上 stderr (standard error)标准错误输出文件 2 将错误信息输出到显示器上 每个文件都有一个唯一的 文件描述符fd, 后面会通过唯一 文件描述符fd 操作对应的信息 Shell程序操作输入输出时用到这3个文件 Shell程序默认会从stdin文件中读取输入数据 Shell程序默认会向stdout文件输出正确数据 Shell程序默认会项stderr文件中输出错误信息 这3个文件用于临时传输数据使用 重定向输入输出介绍 标准输入是数据默认从键盘流向程序，如果改变了它的方向，数据就从其它地方流入，这就是输入重定向。 标准输出是数据默认从程序流向显示器，如果改变了它的方向，数据就流向其它地方，这就是输出重定向。 Linux Shell 重定向分为两种，一种输入重定向，一种是输出重定向； 重定向的作用输出重定向是指命令的结果不再输出到显示器上，而是输出到其它地方，一般是文件中。这样做的最大好处就是把命令的结果保存起来，当我们需要的时候可以随时查询。 重定向语法 命令 说明 命令 &gt; file 将正确数据重定向输出到 file 文件中, 覆盖方式 命令 &lt; file 将输入重定向从 file 文件中读取数据 命令 &gt;&gt; file 将正确数据重定向输出到 file 文件中, 追加方式 命令 &lt; file1 &gt; file2 从file文件读取数据, 输出数据到file2文件中 命令 fd&gt; file 根据指定的文件描述符fd 将数据重定向输出到 file 文件中, 覆盖方式 命令 fd&gt;&gt; file 根据指定的文件描述符fd 将数据重定向输出到 file 文件中, 追加方式 命令 &gt; file fd1&gt;&amp; fd2 将 fd1 和 fd2 文件描述符合并 输出到文件。 fd1&lt;&amp; fd2 将 fd1 和 fd2 文件描述符合并 从文件读取输入. &lt;&lt; tag 读取终端输入数据, 将开始标记 tag 和结束标记 tag 之间的内容作为输入。标记名tag可以任意 在输出重定向中，&gt;代表的是覆盖输出，&gt;&gt;代表的是追加输出。 fd是文件描述符 ​ 0 通常是标准输入（STDIN）， ​ 1 是标准输出（STDOUT）， ​ 2 是标准错误输出（STDERR）。 fd&gt; 或 fd&gt;&gt; 中间不可以有空格 输出示例：正确信息重定向输出创建文件redirect1.txt 1touch redirect1.txt 执行who命令重定向输出到redirect1.txt文件中 1echo &quot;itheima&quot; &gt;&gt; redirect1.txt 输出示例：错误信息重定向输出预览错误消息 1ls java 没有java目录所以报错 将错误消息输出到error.log文件中 1ls java 2&gt; redirect2.txt 2 是标准错误输出（STDERR）, 注意 &gt; 覆盖方式输出 2&gt; 注意fd与&gt;符号之间不能有空格 运行效果 输出示例：正确和错误信息同时输出将正确信息与错误信息都保存到一个文件中 1echo &quot;itcast&quot; &gt; redirect2.txt 2&gt;&amp;1 数字 1 代表正确输出的结果输出到文件中数字 2 代表错误结果输出到文件中 2&gt;&amp; 1 将正确和错误都输出到文件中. 2&gt;&amp; 中间不能有空格, 写法有2种 ​ 合并第一种写法: 2&gt;&amp; 1 ​ 合并第二种写法: 2&gt;&amp;1 运行效果 输入示例：统计文件数据行数wc命令介绍Linux wc 命令可以用来对文本进行统计，包括单词个数、行数、字节数 wc命令语法1wc [options] [文件名] options有如下: 选项 含义 -c character, 统计字节数 -w word, 统计单词数 -l line, 统计行数 演示统计文件redirect2.txt中数据行数 1wc -l &lt; redirect2.txt 运行效果 输入示例：逐行读取文件数据循环读取文件每一行数据 1while read str; do echo $str; done &lt; redirect2.txt 运行效果 输入示例：读取终端输入数据的行数 小结 Shell重定向的含义 改变标准数据流动的方向, a.可以将数据输出到文件中, 叫重定向输出 b.可以读取文件中的数据作为输入, 叫重定向输入 使用重定向输出数据到文件中保存 命令 &gt; file 命令 &gt;&gt; file 命令 2 &gt;&gt; file 命令 &gt; file 2&amp;&gt;1 使用重定向从文件中读取输入数据 命令 &lt; file 命令 &lt; file1 &gt; file2","categories":[{"name":"运维","slug":"运维","permalink":"http://liujun1997.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Linux Shell","slug":"Linux-Shell","permalink":"http://liujun1997.github.io/tags/Linux-Shell/"}]},{"title":"Shell-2","slug":"Shell-2","date":"2021-09-04T07:50:55.000Z","updated":"2022-04-23T12:25:27.943Z","comments":true,"path":"2021/09/04/Shell-2/","link":"","permalink":"http://liujun1997.github.io/2021/09/04/Shell-2/","excerpt":"","text":"Shell字符串变量：格式介绍介绍字符串（String）就是一系列字符的组合。字符串是 Shell 编程中最常用的数据类型之一（除了数字和字符串，也没有其他类型了） 字符串的3种格式 单引号方式 双引号方式, 推荐 不用引号方式 字符串的3种格式区别 使用单引号 &#39;&#39; 的字符串： 任何字符都会原样输出，在拼接字符串中使用变量是无效的。 由双引号&quot; &quot;包围的字符串： 其中包含了变量，那么该变量会被解析得到值，而不是原样输出。 字符串中还可以出现双引号的子字符串，但是需要转义。 不被引号包围的字符串 不被引号包围的字符串中出现变量时也会被解析，这一点和双引号&quot; &quot;包围的字符串一样。 字符串中不能出现空格，否则空格后边的字符串会作为其他命令解析。 获取字符串的长度语法1$&#123;#字符串变量名&#125; 含义获取字符串的字符长度 演示 小结能够使用字符串的3种方式 单引号方式 双引号方式[推荐] 不使用引号方式 掌握3种方式的区别 单引号, 原样输出, 不会解析里面的变量 双引号, 会解析里面的变量, 并且可以使用子双引号, 需要转义 不使用引号, 也会解析里面的变量, 但是不能含有空格, 空格后面的字符串会作为命令去执行 能够获取字符串的长度 ${&#35;var_name} Shell字符串变量：拼接目标掌握Shell字符串拼接 字符串拼接方式 无符号拼接 双引号拼接 混合拼接 演示 小结 无符号拼接 双引号拼接 混合拼接 Shell字符串变量：字符串截取目标掌握shell字符串截取的常用格式 语法 格式 说明 $&#123;变量名:start:length&#125; 从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。start从0开始 $&#123;变量名:start&#125; 从 string 字符串的左边第 start 个字符开始截取，直到最后。 $&#123;变量名:0-start:length&#125; 从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。start从1开始, 代表右侧第一个字符 $&#123;变量名:0-start&#125; 从 string 字符串的右边第 start 个字符开始截取，直到最后。 $&#123;变量名#*chars&#125; 从 string 字符串左边第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。 $&#123;变量名##*chars&#125; 从 string 字符串左边最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。 $&#123;变量名%chars*&#125; 从 string 字符串右边第一次出现 chars* 的位置开始，截取 chars* 左边的所有字符。 $&#123;变量名%%chars*&#125; 从 string 字符串右边最后一次出现 chars* 的位置开始，截取 chars* 左边的所有字符 示例要求字符串”welcome to itheima” 1234567# 从左侧第0个开始,向左截取2个字符# 从左侧第11个开始,向左截取所有字符# 从右侧第5个开始,向右截取2个字符# 截取左边第一次出现字符e右边的所有字符# 截取左边最后一次出现字符e右边的所有字符# 截取右边第一次次出现字符e左边的所有字符# 截取右边最后一次出现字符e左边的所有字符 截取演示从左侧第0个开始,向左截取2个字符 从左侧第11个开始,向左截取所有字符 从右侧第5个开始,向右截取2个字符 截取左边第一次出现字符e右边的所有字符 截取左边最后一次出现字符e右边的所有字符 截取右边第一次次出现字符e左边的所有字符 截取右边最后一次出现字符e左边的所有字符 小结 格式 说明 $&#123;变量名: start :length&#125; 从左边start位置开始截取length个字符长度, 从0开始 $&#123;变量名: start&#125; 从左边start位置开始截取到最后所有字符 Shell索引数组变量：定义-获取-拼接-删除目标 能够定义Shell数组 能够获取Shell数组数据 能够进行Shell数组的拼接, 删除 介绍Shell 支持数组（Array）, 数组是若干数据的集合，其中的每一份数据都称为数组的元素。 注意Bash Shell 只支持一维数组，不支持多维数组。 数组的定义语法在 Shell 中，用括号( )来表示数组，数组元素之间用空格来分隔. 语法为： 12array_name=(item1 item2 ...) # 方式1array_name=([索引下标1]=item1 [索引下标2]=item2 ...) # 方式2 注意，赋值号 = 两边不能有空格 演示1.定义数字存储100,3,22,58,77,17,20 1nums=(29 100 13 8 91 44) 2.Shell 是弱类型的，它并不要求所有数组元素的类型必须相同 1arr=(20 56 &quot;http://www.itcast.cn/&quot;) Shell数组元素定义后不是固定的, 定义后还可以赋值 1arr[6]=100 3.可以给指定元素赋值初始化 1arr2=([0]=1 [2]=100 [4]=aa) 由于上面只赋值了3个元素, 所以数组的长度是3 数组的获取语法1.通过下标获取元素值,index从0开始 1$&#123;arr[index]&#125; 注意使用&#123; &#125; 2.获取值同时复制给其他变量 1item=$&#123;arr[index]&#125; 3.使用 @ 或 * 可以获取数组中的所有元素 12$&#123;arr[@]&#125;$&#123;arr[*]&#125; 4.获取数组的长度或个数 12$&#123;#arr[@]&#125;$&#123;#arr[*]&#125; 5.获取数组指定元素的字符长度 1$&#123;#arr[索引]&#125; 演示 数组的拼接介绍所谓 Shell 数组拼接（数组合并），就是将两个数组连接成一个数组 语法使用 @ 和 * 获取数组所有元素之后进行拼接 12array_new=($&#123;array1[@]&#125; $&#123;array2[@]&#125; ...)array_new=($&#123;array1[*]&#125; $&#123;array2[*]&#125; ...) 演示 数组的删除介绍删除数组指定元素数据和删除整个数组数据 语法删除数组指定元素数据 1unset array_name[index] 删除整个数组 1unset array_name 演示 小结1.能够定义Shell数组 12array_name=(item1 item2 ...)array_name=([索引1]=item1 [索引2]=item2 ...) 2.能够获取Shell数组数据 123$&#123;array_name[索引下标]&#125;$&#123;array_name[*]&#125;$&#123;array_name[@]&#125; 3.数组的拼接 1array_newname=($&#123;array_name1[*]&#125; $&#123;array_name2[*]&#125; ...) 4.数组的删除 12unset array_name[索引] unset array_name Shell内置命令：alias设置别名目标1.理解内置命令的含义 2.能够使用alias内置命令进行给命令定义别名 内置命令介绍Shell 内置命令，就是由 Bash Shell 自身提供的命令，而不是文件系统中的可执行脚本文件。 使用type 来确定一个命令是否是内置命令： 1type 命令 通常来说，内置命令会比外部命令执行得更快，执行外部命令时不但会触发磁盘 I/O，还需要 fork 出一个单独的进程来执行，执行完成后再退出。而执行内置命令相当于调用当前 Shell 进程的一个函数, 还是在当前Shell环境进程内, 减少了上下文切换。 内置命令列表 命令 说明 : 扩展参数列表，执行重定向操作 . 读取并执行指定文件中的命令（在当前 shell 环境中） alias 为指定命令定义一个别名 bg 将作业以后台模式运行 bind 将键盘序列绑定到一个 readline 函数或宏 break 退出 for、while、select 或 until 循环 builtin 执行指定的 shell 内建命令 caller 返回活动子函数调用的上下文 cd 将当前目录切换为指定的目录 command 执行指定的命令，无需进行通常的 shell 查找 compgen 为指定单词生成可能的补全匹配 complete 显示指定的单词是如何补全的 compopt 修改指定单词的补全选项 continue 继续执行 for、while、select 或 until 循环的下一次迭代 declare 声明一个变量或变量类型。 dirs 显示当前存储目录的列表 disown 从进程作业表中刪除指定的作业 echo 将指定字符串输出到 STDOUT enable 启用或禁用指定的内建shell命令 eval 将指定的参数拼接成一个命令，然后执行该命令 exec 用指定命令替换 shell 进程 ==exit 强制 shell 以指定的退出状态码退出 export 设置子 shell 进程可用的变量 fc 从历史记录中选择命令列表 fg 将作业以前台模式运行 getopts 分析指定的位置参数 hash 查找并记住指定命令的全路径名 help 显示帮助文件 history 显示命令历史记录 jobs 列出活动作业 kill 向指定的进程 ID(PID) 发送一个系统信号 let 计算一个数学表达式中的每个参数 local 在函数中创建一个作用域受限的变量 logout 退出登录 shell mapfile 从 STDIN 读取数据行，并将其加入索引数组 popd 从目录栈中删除记录 printf 使用格式化字符串显示文本 pushd 向目录栈添加一个目录 pwd 显示当前工作目录的路径名 read 从 STDIN 读取一行数据并将其赋给一个变量 readarray 从 STDIN 读取数据行并将其放入索引数组 readonly 从 STDIN 读取一行数据并将其赋给一个不可修改的变量 return 强制函数以某个值退出，这个值可以被调用脚本提取 set 设置并显示环境变量的值和 shell 属性 shift 将位置参数依次向下降一个位置 shopt 打开/关闭控制 shell 可选行为的变量值 source 读取并执行指定文件中的命令（在当前 shell 环境中） suspend 暂停 Shell 的执行，直到收到一个 SIGCONT 信号 test 基于指定条件返回退出状态码 0 或 1 times 显示累计的用户和系统时间 trap 如果收到了指定的系统信号，执行指定的命令 type 显示指定的单词如果作为命令将会如何被解释 typeset 声明一个变量或变量类型。 ulimit 为系统用户设置指定的资源的上限 umask 为新建的文件和目录设置默认权限 unalias 刪除指定的别名 unset 刪除指定的环境变量或 shell 属性 wait 等待指定的进程完成，并返回退出状态码 alisa 介绍alisa 用于给命令创建别名。 好处: 可以将经常操作比较复杂的命令进行设置别名, 通过别名的操作提高工作效率 若该命令且不带任何参数，则显示当前 Shell 进程中的所有别名列表。 上面是系统为了方便命令操作默认将部分命令创建为别名 ll 的命令与ls -l的效果一样, 就是因为ll是别名 alias别名定义语法1alias 别名=&quot;命令&quot; 这里使用单引号或双引号都可以 unalias 别名删除语法删除指定的别名 1unalias 别名 删除当前Shell环境中所有的别名 1unalias -a 注意: 以上2种方式删除都是临时删除当前Shell的别名, 如果想永久删除必须去配置文件中手动删除 alias演示输出所有进行信息 1ps -aux 给上面的命令起别名为psList, 并使用psList输出 删除psList别名 小结1.理解内置命令的含义 就是Shell内部提供的命令, 可以直接使用 内置命令与外部的脚本文件执行区别 ​ 内置命令: 执行速度快, 内置命令执行是当前Shell环境的一部分, 就在当前进程内执行, 减少了上下文切换 ​ 外部的脚本文件: 执行速度慢, 需要磁盘I/O操作, 并且是fork一个新的进程运行脚本文件,导致进程之间上下文切换 2.能够使用alias内置命令 定义别名语法: alias 别名=&quot;命令&quot; 删除别名: unalias 别名 Shell内置命令：echo输出字符串目标1.能够echo输出不换行的字符串 2.能够使用echo输出转义字符 echo命令介绍echo 是一个 Shell 内置命令，用于在终端输出字符串，并在最后默认加上换行符 echo输出语法默认输出换行语法 1echo 字符串 输出不换行语法 1echo -n 字符串 输出演示1.创建echo1.sh 1touch echo1.sh 2.编辑文件内容并保存 1vim echo1.sh 文件内容 12345#!/bin/bashecho &quot;hello&quot;echo &quot;world&quot;echo -n &quot;itheima &quot;echo -n &quot;shell &quot; 3.运行echo1.sh文件观察效果 itheima shell输出为一行 echo输出转义字符\\n 转义字符用于echo输出字符串非结尾处的换行, 但是默认echo无法解析/n 转义字符 演示 -e 参数-e 参数用于解析转义字符 1echo -e &#x27;字符串中含有转义字符&#x27; 演示 /c 转义字符/c 用于强制清除echo的结尾换行输出 演示 小结1.echo输出不换行的字符串 echo -n 输出的数据 2.echo输出转义字符有哪些 \\n 换行字符 \\c 清除echo结尾的换行 echo -e 含有转义字符的数据 Shell内置命令：read读取控制台输入目标理解read命令的作用 使用read给多个变量赋值 使用read读取1个字符 使用read限制时间输入 介绍read 是 Shell 内置命令，用于从标准输入中读取数据并赋值给变量。如果没有进行重定向，默认就是从终端控制台读取用户输入的数据；如果进行了重定向，那么可以从文件中读取数据。 后续讲解Shell重定向 语法1read [-options] [var1 var2 ...] options表示选项，如下表所示；var表示用来存储数据的变量，可以有一个，也可以有多个。 options和var都是可选的，如果没有提供变量名，那么读取的数据将存放到环境变量 REPLY 变量中。 $REPLY保存read最后一个读入命令的数据 options支持的参数 选项 说明 -a array 把读取的数据赋值给数组 array，从下标 0 开始。 -d delimiter 用字符串 delimiter 指定读取结束的位置，而不是一个换行符（读取到的数据不包括 delimiter）。 -e 在获取用户输入的时候，对功能键进行编码转换，不会直接显式功能键对应的字符。 ==-n num== 读取 num 个字符，而不是整行字符。 ==-p prompt== 显示提示信息，提示内容为 prompt。 -r 原样读取（Raw mode），不把反斜杠字符解释为转义字符。 ==-s== 静默模式（Silent mode），不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这是很有必要的。 ==-t seconds== 设置超时时间，单位为秒。如果用户没有在指定时间内输入完成，那么 read 将会返回一个非 0 的退出状态，表示读取失败。 -u fd 使用文件描述符 fd 作为输入源，而不是标准输入，类似于重定向。 示例1：多个变量赋值需求使用 read 命令给多个变量赋值 步骤编辑文件read1.sh脚本文件 12# 使用read命令读取数据,要有提示信息&quot;请输入姓名,年龄,爱好:&quot; 将数据赋值给多个变量# 打印每一个变量的值 演示创建文件 1touch read1.sh 编辑文件 1vim read1.sh read1.sh文件内容 12345#!/bin/bashread -p &quot;请输入姓名,年龄,爱好: &quot; name age hobbyecho &quot;姓名：$name&quot;echo &quot;年龄：$age&quot;echo &quot;爱好：$hobby&quot; 运行效果 示例2：读取一个字符需求从终端控制台只读取一个字符 步骤编辑文件read2.sh脚本文件 12# 使用read命令读取数据,要有提示信息&quot;您确定要删除数据吗?(请输入y/n):&quot; 并且设置读取一个字符# 打印这个字符输出 演示创建文件 1touch read2.sh 编辑文件 1vim read2.sh read2.sh文件内容 1234#!/bin/bashread -n 1 -p &#x27;请输入一个字符: &#x27; charprintf &#x27;\\n&#x27;echo &#x27;你输入的字符为:&#x27;$char 注意 -n 1只读取一个字符。运行脚本后，只要输入的一个字符，立即读取结束，不用等待用户按下回车键。 printf &#39;\\n&#39;语句用于换行，否则 echo 的输出结果会和用户输入的内容位于同一行，不容易区分 运行效果 示例3：限制时间输入需求在终端控制台输入时, 设置指定时间内输入密码 步骤编辑文件read3.sh脚本文件 12345# 使用read命令读取数据,要有提示信息&quot;请输入密码(20秒内):&quot; 并且设置限制时间20秒# 输出一个换行# 使用read命令读取数据,要有提示信息&quot;请再次输入密码(20秒内):&quot; 并且设置限制时间20秒# 输出一个换行# 校验密码与再次输入的密码是否一致 演示创建文件 1touch read3.sh 编辑文件 1vim read3.sh read3.sh文件内容 123456789101112#!/bin/bashread -t 20 -sp &#x27;请输入密码(20秒内):&#x27; pwd1printf &#x27;\\n&#x27;read -t 20 -sp &#x27;请再次输入密码(20秒内):&#x27; pwd2printf &#x27;\\n&#x27;if [ $pwd1 == $pwd2 ]then echo &#x27;密码与确认密码一致, 验证通过&#x27;else echo &#x27;密码与确认密码不一致,验证失败&#x27;fi 执行文件运行效果 小结read命令是什么 用于读取标准输入(终端控制台用户输入的数据) read给多个变量赋值 read var1 var2 ... read读取1个字符 read -n 1 var1 read限制时间输入 read -t 秒数 var1 Shell内置命令：exit退出目标掌握exit的应用场景 介绍exit 用于退出当前Shell环境进程结束运行, 并且可以返回一个状态码.一般使用 $? 可以获取退出状态码 语法正确退出语法 1exit # 默认返回状态码0, 一般代表命令执行成功 错误退出语法 1exit 非0数字 # 数字建议的范围0~255, 一般代表命令执行失败 exit应用场景1.结束当前Shell进程 2.当Shell 进程执行出错退出时，可以返回不同的状态值代表不同的错误 比如执行一个脚本文件里面操作一个文件时，可以返回1 表示文件不存在，2 表示文件没有读取权限，3 表示文件类型不对。 示例：Shell脚本文件中使用exit退出需求编写Shell脚本使用exit 退出, 退出时返回一个非0数字状态值, 执行脚本文件并打印返回状态值 步骤1.创建exit.sh文件 2.编辑exit.sh文件, 使用exit 数字 退出结束当前Shell 3.执行文件,打印返回状态值 演示创建文件 1touch exit.sh 编辑文件 1vim exit.sh exit.sh文件内容: 使用exit 数字 退出结束当前Shell 1234#!/bin/bashecho &#x27;one&#x27;exit 6echo &#x27;two&#x27; 运行效果 小结exit的应用场景 1.结束当前Shell进程 2.可以返回不同的状态码, 用于不同的业务处理 Shell内置命令：declare设置变量目标1.能够使用declare设置变量的属性 2.能够使用declare查看全部Shell变量与函数 3.能够使用declare实现索引数组与关联数组变量 介绍declare命令用于声明 shell 变量。可用来声明变量并设置变量的属性，也可用来显示shell函数。若不加上任何参数，则会显示全部的shell变量与函数(与执行set指令的效果相同)。 declare命令作用1.declare设置变量的属性[重要] 2.查看全部Shell变量与函数 3.实现关联数组变量[重要] declare设置变量的属性语法1declare [+/-][aArxif][变量名称＝设置值] +/- “-“可用来指定变量的属性，”+”则是取消变量所设的属性。 a array,设置为普通索引数组 A Array,设置为key-value关联数组 r readonly,将变量设置为只读, 也可以使用readonly x exprot,设置变量成为全局变量，也可以使用export i int,设置为整型变量。 f function,设置为一个函数变量 示例1：设置变量属性需求操作一个变量属性, 设置为整型\\ 取消整型\\设置为只读等操作 步骤 使用declare设置一个整型变量并赋值 取消变量的整型类型, 尝试设置其他类型值尝试 设置变量只读, 尝试赋值测试 演示 查看全部Shell变量与函数定义语法1declare [-fF] declare 后无参数, 查询全部Shell变量与函数定义, 与set功能一模一样 -f 查询仅显示函数定义。 -F 查询仅显示函数名字 示例2：查看当前Shell所有函数名查看所有变量与所有函数 1declare 查看所有函数与定义 1declare -f 查询所有函数名列表 1declare -F 实现key-value关联数组变量语法关联数组也称为“键值对（key-value）”数组，键（key）也即字符串形式的数组下标，值（value）也即元素值。 1declare -A 关联数组变量名=([字符串key1]=值1 [字符串key2]=值2 ...) declare也可以用于定义普通索引数组, -a 参数创建普通或索引数组 -A 创建关联数组 declare -a 关联数组变量名=(值1 值2 ...) declare -a 关联数组变量名=([0]=值1 [1]=值2 ...) 获取指定key的值 1$&#123;关联数组变量名[key]&#125; 获取所有值 12$&#123;关联数组变量名[*]&#125; # 方式1$&#123;关联数组变量名[@]&#125; # 方式2 示例3：实现普通索引数组需求使用declare定义一普通数组,并获取打印元素数据的值 步骤1.创建declare1.sh文件 2.编辑declare1.sh文件内容, 使用declare定义普通数组数据与打印 2.执行文件 演示创建文件 1touch declare1.sh 编辑文件 1vim declare1.sh declare1.sh文件内容 1234567891011#!/bin/bashdeclare -a arr1=(1 2 3 aa)echo $&#123;arr1[1]&#125;echo $&#123;arr1[*]&#125;declare -a arr2=([0]=1 [1]=2 [2]=3 [4]=aa)echo $&#123;arr2[1]&#125;echo $&#123;arr2[*]&#125;declare -a arr2[3]=4echo $&#123;arr2[*]&#125; 运行结果 示例4：实现key-value关联数组需求使用declare定义关联数组并打印输出 演示 注意: 使用参数-A 才是关联数组 , 关联数组无法使用索引获取 小结1.使用declare设置变量的属性(重点) declare [+/-][aArxif] 变量名=变量值 2.使用declare查看全部Shell变量与函数 declare declare -f 查询所有函数的定义 declcare -F 查询所欲函数的名称列表 3.使用declare实现普通索引数组和关联数组变量(重点) 索引数组: declare -a array_name=(item1 item2 ...) 关联数组: declare -A array_name=([字符串key1]=item1 [字符串key2]=item2 ...) Shell运算符：算术运算符目标掌握算术运算符的使用 掌握expr求值表达式命令 expr命令介绍expr 是 evaluate expressions 的缩写，译为“求值表达式”。Shell expr 是一个功能强大，并且比较复杂的命令，它除了可以实现整数计算，还可以结合一些选项对字符串进行处理，例如计算字符串长度、字符串比较、字符串匹配、字符串提取等, 后续讲解。 expr语法计算语法 1expr 算术运算符表达式 注意: 运算表达式 获取计算结果赋值给新变量语法 1result=`expr 算术运算符表达式` 演示 注意: 运算符表达式中每个数字与符号之间要有空格 算术运算符介绍下表列出了常用的算术运算符，假定变量 a 为 1，变量 b 为 2： 运算符 说明 举例 + 加法 expr $a + $b 结果为 3 - 减法 expr $a - $b 结果为 -1 * 乘法 expr $a \\* $b 结果为 2 / 除法 expr $b / $a 结果为 2 % 取余 expr $b % $a 结果为 0 = 赋值 a=$b 将把变量 b 的值赋给 a 四则运算中如果使用了(), 也需要转义 \\( 1 + 1 \\) 算术运算符演示operation1.sh脚本代码 123456789#!/bin/basha=1 b=2 # 声明变量a=1和b=2echo &quot;a=$&#123;a&#125; b=$&#123;b&#125;&quot;echo &quot;a + b = `expr $a + $b`&quot;echo &quot;a * b = `expr $a \\* $b`&quot;echo &quot;a - b = `expr $a - $b`&quot;echo &quot;a * b = `expr $a \\* $b`&quot;echo &quot;b / a = `expr $b / $a`&quot;echo &quot;b % a = `expr $b % $a`&quot; 小结常见算术运算符的使用 + - \\* / % expr执行运算命令 expr 表达式 变量名=`expr 表达式` Shell运算符： 比较运算符目标 了解有哪些比较运算符 掌握推荐使用哪个比较运算符 整数比较运算符语法下表列出了常用的比较运算符，假定变量 a 为 1，变量 b 为 2： 运算符 说明 举例 -eq equals 检测两个数是否相等，相等返回 0, 否则返回1。 [ $a -eq $b ] 返回 1。 -ne not equals检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 0。 -gt greater than检测左边的数是否大于右边的,是返回0, 否则1 [ $a -gt $b ] 返回 1。 -lt lower than检测左边的数是否小于右边的,是返回0, 否则1 [ $a -lt $b ] 返回 0。 -ge greater equals检测左边的数是否大于等于右边的,是返回0, 否则1 [ $a -ge $b ] 返回 1。 -le lower equals检测左边的数是否小于等于右边的,是返回0, 否则1 [ $a -le $b ] 返回 0。 &lt; 检测左边的数是否小于右边的,是返回0, 否则1 (($a&lt;$b)) 返回0 &lt;= 检测左边的数是否小于等于右边的,是返回0, 否则1 (($a&lt;=$b)) 返回0 &gt; 检测左边的数是否大于右边的,是返回0, 否则1 (($a&gt;$b)) 返回1 &gt;= 检测左边的数是否大于等于右边的,是返回0, 否则1 (($a&gt;=$b)) 返回1 == 检测左边的数是否等于右边的,是返回0, 否则1 (($a==$b)) 返回1 != 检测左边的数是否不等于右边的,是返回0, 否则1 (($a!=$b)) 返回0 注意: 整数比较运算符只支持整数，不支持小数与字符串(字符串比较后续讲解)，除非字符串的值是整数数字。 每个命令都有返回值, 这个后面我们会讲解退出状态再具体说明, 返回0代表成功, 返回1代表失败 演示operation2.sh脚本代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/bin/basha=1 b=2echo &quot;a=$&#123;a&#125; b=$&#123;b&#125;&quot;if [ $a -eq $b ]then echo &quot;$a -eq $b : a 等于 b&quot;else echo &quot;$a -eq $b: a 不等于 b&quot; # 输出这个fiif [ $a -ne $b ]then echo &quot;$a -ne $b: a 不等于 b&quot; # 输出这个else echo &quot;$a -ne $b : a 等于 b&quot;fiif [ $a -gt $b ]then echo &quot;$a -gt $b: a 大于 b&quot;else echo &quot;$a -gt $b: a 不大于 b&quot; # 输出这个fiif [ $a -lt $b ]then echo &quot;$a -lt $b: a 小于 b&quot; # 输出这个else echo &quot;$a -lt $b: a 不小于 b&quot;fiif [ $a -ge $b ]then echo &quot;$a -ge $b: a 大于或等于 b&quot;else echo &quot;$a -ge $b: a 小于 b&quot; # 输出这个fiif [ $a -le $b ]then echo &quot;$a -le $b: a 小于或等于 b&quot; # 输出这个else echo &quot;$a -le $b: a 大于 b&quot;fiif (($a &gt; $b))then echo &quot;$a &gt; $b: a 大于 b&quot;else echo &quot;$a &gt; $b: a 不大于 b&quot;fiif (($a &lt; $b))then echo &quot;$a &lt; $b: a 小于 b&quot;else echo &quot;$a &lt; $b: a 不小于 b&quot;fiif (($a &gt;= $b))then echo &quot;$a &gt;= $b: a 大于或等于 b&quot;else echo &quot;$a &gt;= $b: a 小于 b&quot;fiif (($a &lt;= $b))then echo &quot;$a &lt;= $b: a 小于或等于 b&quot;else echo &quot;$a &lt;= $b: a 大于 b&quot;fi 运行效果 字符串比较运算符介绍可以比较2个变量, 变量的类型可以为数字（整数，小数）与字符串 语法下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”： 字符串比较可以使用 [[]] 和 [] 2种方式 运算符 说明 举例 == 或 = 相等。用于比较两个字符串或数字，相同则返回 0。可以使用= [ $a == $b ] 返回1 [ $a = $b ] 返回 1[[ $a == $b ]] 返回1[[ $a = $b ]] 返回1 != 不相等。用于比较两个字符串或数字，不相同则返回 0。 [ $a != $b ] 返回 0[[ $a != $b ]] 返回 0 &lt; 小于, 用于比较两个字符串或数字， 小于返回0， 否则返回1 [ $a \\&lt; $b ] 返回 0[[ $a &lt; $b ]] 返回 0 &gt; 大于, 用于比较两个字符串或数字， 大于返回0， 否则返回1 [ $a \\&gt; $b ] 返回 1[[ $a &gt; $b ]] 返回 1 -z 检测字符串长度是否为0，如果长度为0返回则返回0, 否则返回1。 [ -z $a ] 返回 false。 -n 检测字符串长度是否不为 0，如果长度不为 0 则返回0, 否则返回1。 [ -n “$a” ] 返回 true。 $ 检测字符串是否不为空，不为空返回0, 为空返回1。 [ $a ] 返回 true。 字符串比较没有 &lt;= 可以通过 [[ &quot;a&quot; &lt; &quot;b&quot; &amp;&amp; &quot;a&quot; == &quot;b&quot; ]] 演示operation6.sh脚本代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/bin/basha=&quot;itheima&quot; b=&quot;itcast&quot; c=1 d=2echo &quot;a=$&#123;a&#125;,b=$&#123;b&#125;,c=$&#123;c&#125;,d=$&#123;d&#125;&quot;if [ $a = $b ]then echo &quot;$a = $b : a 等于 b&quot;else echo &quot;$a = $b: a 不等于 b&quot;fiif [ $a != $b ]then echo &quot;$a != $b : a 不等于 b&quot;else echo &quot;$a != $b: a 等于 b&quot;fiif [[ $a &gt; $b ]]then echo &quot;$a &gt; $b : a 大于 b&quot;else echo &quot;$a &gt; $b: a 不大于 b&quot;fiif [ $a \\&gt; $b ]then echo &quot;$a &gt; $b : a 大于 b&quot;else echo &quot;$a &gt; $b: a 不大于 b&quot;fiif [[ $c &gt; $d ]]then echo &quot;$c &gt; $d : c 大于 d&quot;else echo &quot;$c &gt; $d: c 不大于 d&quot;fiif [ -z $a ]then echo &quot;-z $a : 字符串长度为 0&quot;else echo &quot;-z $a : 字符串长度不为 0&quot;fiif [ -n &quot;$a&quot; ]then echo &quot;-n $a : 字符串长度不为 0&quot;else echo &quot;-n $a : 字符串长度为 0&quot;fiif [ $a ]then echo &quot;$a : 字符串不为空&quot;else echo &quot;$a : 字符串为空&quot;fi 运行效果 [[]] 和 [] 的区别区别1: word splitting的发生区别说明[[]] 不会有word splitting发生 [] 会有word splitting发生 word splitting介绍会将含有空格字符串进行分拆分割后比较 示例 通过 $? 获取上一个命令的退出状态, 0代表成功, 1代表失败 区别2: 转义字符区别说明[[]] 对 &lt; 不需要转义, 格式为 [[ 字符串1 &lt; 字符串2 ]] [] 需要对 &lt;,&gt; 转义 , 格式为 [ 字符串1 \\&lt; 字符串2 ] 示例[] 执行效果 [[]] 执行效果, 不需要转义执行结果正确 小结 了解有哪些比较运算符 整数比较运算符 比较方式: [] 和 (()) 方式1: [ 整数1 options 整数2 ] options: -eq -gt -ge -lt -le -ne 方式2: ((整数1 options 整数2)) options: &lt; &lt;= &gt; &gt;= == != 注意判断等于不可以使用= ,等于在(())里面是赋值的含义 字符串,数字比较运算符 介绍: 可以比较2个变量, 变量的类型可以为字符串, 数字(整数,小数) 比较方式: [] 和 [[]] 方式1: [ 变量1 options 整数2 ] ​ options: &lt;,&gt;,==,=,!= ​ &lt;,&gt; 需要转义 ​ 会发生word splitting 方式2: [[ 变量1 options 变量2]] ​ options: &lt;,&gt;,==,=,!= ​ &lt;,&gt; 不需要转义 不会发生word splitting 推荐使用哪个比较运算符? [[ 表达式 ]] 即可以实现数字和字符串比较, 并且不需要转义, 不会word splitting Shell运算符： 布尔运算符目标掌握布尔运算符的使用 介绍 运算符 说明 举例 ! 非运算，取反, 表达式为 true 则返回 false，否则返回 true。 [ ! 表达式 ] 取反。 -o or 或运算，有一个表达式为 true 则返回 true。 [ 表达式1 -o 表达式2 ] -a and 与运算，两个表达式都为 true 才返回 true。 [ 表达式1 -a 表达式2 ] 注意布尔运算符放在[] 或 与test命令配合使用才有效 布尔运算符常与与test命令配合使用, 后续讲解 演示operation4.sh脚本代码脚本代码 1234567891011121314151617181920212223#!/bin/basha=1 b=2if [ $a -lt 2 -a $b -gt 10 ]then echo &quot;$a 小于 2 且 $b 大于 10 : 返回 true&quot; else echo &quot;$a 小于 2 且 $b 大于 10 : 返回 false&quot; # $b -gt 10不成立, 输出这个表达式fiif [ $a -lt 10 -o $b -gt 10 ]then echo &quot;$a 小于 10 或 $b 大于 10 : 返回 true&quot; # $a -lt 10 成立, 输出这个表达式else echo &quot;$a 小于 10 或 $b 大于 10 : 返回 false&quot;fiif [ ! $a -gt $b ]then echo &quot;$a 大于 $b 取反 : 返回 true&quot;else echo &quot;$a 大于 $b 取反 : 返回 false&quot; # $a -gt $b 为true , 取反为false, 输出这个表达式fi 运行效果 小结布尔运算符的使用 ! 取反 -o or, 或者, 只要有一个表达式成立返回0, 那么就返回0 -a and, 并且, 需要多个表达式必须全部成立才返回0, 否则返回1 布尔运算符必须与[]使用 或者 与test命令一起使用, 后续讲解test命令 Shell运算符： 逻辑运算符目标 能够使用逻辑运算符 能够理解逻辑运算符与布尔运算符区别 介绍 运算符 说明 举例 &amp;&amp; 逻辑的 AND [[ 表达式1 &amp;&amp; 表达式2 ]] ` ` ! 逻辑非 [[ ! 表达式 ]] 注意 使用&amp;&amp; 和 || 的运算符必须放在 [[]] 或 (())中才有效, 否则报错 ! 可以用在[],[[]]中, 不可以在(()) 演示operation5.sh脚本代码 1234567891011121314151617#!/bin/basha=1 b=2if [[ $a -lt 10 &amp;&amp; $b -gt 10 ]]then echo &quot;返回 true&quot; else echo &quot;返回 false&quot; # $b -gt 10 不成立, 输出falsefiif [[ $a -lt 10 || $b -gt 10 ]]then echo &quot;返回 true&quot; # $a -lt 10 成立, 输出trueelse echo &quot;返回 false&quot; fi 运行效果 小结 使用逻辑运算符 ! 逻辑非 &amp;&amp; 逻辑与 || 逻辑或 理解逻辑运算符与布尔运算符区别 布尔运算符: ! -o -a ​ 必须有[] 或test命令执行 逻辑运算符: ! || &amp;&amp; ​ || &amp;&amp; 必须有[[]] 或 (()) 执行 ​ ! 可以用在 [] 或 [[]] , 不可以用在(()) Shell运算符： 文件测试运算符目标能够使用常用文件测试运算符检查文件 例如: 文件是否存在\\是否可读\\是否可执行\\是否为空\\是否可写\\是否是目录\\是否是普通文件 linux系统文件类型介绍-：普通文件 d：目录文件 l：链接文件 b：块设备文件 c：字符设备文件 块设备文件: 比如计算机硬盘/dev/sda 字符设备文件: 比如计算机的USB文件/dev/usb 设备文件都是对应计算机硬件的, 不同的设备文件代表不同的传输数据方式 p：管道文件 介绍文件测试运算符用于检测文件的各种属性。 属性检测描述如下： 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 ==-d file== directory, 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 ==-f file== file, 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是有名管道文件，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 ==-r file== read,检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 ==-w file== write,检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 ==-x file== execute, 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 ==-s file== size, 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 ==-e file== exists, 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 file1 -nt file2 new than(nt), file1是否比file2新 [ file1 -nt file2 ] file1 -ot file2 old than(ot), file1是否比file2旧 [ file1 -ot file2 ] 其他检查符： -S: 判断某文件是否 socket。 -L: link, 检测文件是否存在并且是一个符号链接。 语法 123[ options 文件路径字符串]或[[ options 文件路径字符串 ]] 演示operation6.sh脚本代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/bin/bashfile=&quot;/root/operation1.sh&quot;if [ -w $file ]then echo &quot;文件可写&quot;else echo &quot;文件不可写&quot;fiif [ -r $file ]then echo &quot;文件可读&quot;else echo &quot;文件不可读&quot;fiif [ -x $file ]then echo &quot;文件可执行&quot;else echo &quot;文件不可执行&quot;fiif [ -f $file ]then echo &quot;文件是普通文件&quot;else echo &quot;文件是特殊文件&quot;fiif [ -s $file ]then echo &quot;文件不是空&quot;else echo &quot;文件是空&quot;fiif [ -e $file ]then echo &quot;文件存在&quot;else echo &quot;文件不存在&quot;fiif [ -d $file ]then echo &quot;文件是目录&quot;else echo &quot;文件不是目录&quot;fifile2=&quot;/root/operation2.sh&quot;if [ file -nt file2 ]then echo &quot;operation1.sh文件比operation2.sh文件新&quot;else echo &quot;operation1.sh文件不比operation2.sh文件新&quot;fi 运行效果 operation1.sh文件不可执行, 因为没有可执行权限 查看operation1.sh文件权限 给operation1.sh添加执行权限 重新执行operation6.sh 小结常用文件测试运算符 文件是否存在: -e 是否可读 : -r 是否可执行: -x 是否为空: -s 是否可写: -w 是否是目录: -d 是否是普通文件: -f","categories":[{"name":"运维","slug":"运维","permalink":"http://liujun1997.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Linux Shell","slug":"Linux-Shell","permalink":"http://liujun1997.github.io/tags/Linux-Shell/"}]},{"title":"Shell-1","slug":"Shell-1","date":"2021-09-04T07:39:55.000Z","updated":"2022-04-23T12:25:27.943Z","comments":true,"path":"2021/09/04/Shell-1/","link":"","permalink":"http://liujun1997.github.io/2021/09/04/Shell-1/","excerpt":"","text":"Shell脚本入门：介绍Shell介绍通过编写Shell命令发送给linux内核去执行, 操作就是计算机硬件. 所以Shell命令是用户操作计算机硬件的桥梁, Shell是命令, 类似于windows系统Dos命令 Shell是一个门程序设计语言, Shell里面含有变量, 函数, 逻辑控制语句等等 Shell脚本通过Shell命令或程序编程语言编写的Shell文本文件, 这就是Shell脚本 , 也叫Shell程序 为什么学习Shell脚本?通过Shell命令与编程语言来提高linux系统的管理工作效率 Shell的运行过程当用户下达指令给该操作系统的时候，实际上是把指令告诉shell，经过shell解释，处理后让内核做出相应的动作。 系统的回应和输出的信息也由shell处理，然后显示在用户的屏幕上。 Shell解析器查看linux系统centos支持的shell解析器 1cat /etc/shells 效果 介绍解析器类型 解析器类型 介绍 /bin/sh Bourne Shell,是UNIX最初使用的shell; /bin/bash Bourne Again Shell它是Bourne Shell的扩展，简称bash，是LinuxOS默认shell,有灵活和强大的编辑接口，同时又很友好的用户界面，交互性很强； /sbin/nologin 未登录解析器, shell设置为/sbin/nologin 是用于控制用户禁止登陆系统的, 有时候有些服务，比如邮件服务，大部分都是用来接收主机的邮件而已，并不需要登陆 /bin/dash dash（Debian Almquist Shell），也是一种 Unix shell。它比 Bash 小，只需要较少的磁盘空间，但是它的对话性功能也较少，交互性较差。 /bin/csh C Shell是C语言风格Shell /bin/tcsh 是C Shell的一个扩展版本。 Centos默认的解析器是bash语法 1echo $SHELL 含义: 打印输出当前系统环境使用的Shell解析器类型 echo 用于打印输出数据到终端 $SHELL 是全局共享的读取解析器类型环境变量, 全局环境变量时所有的Shell程序都可以读取的变量, 效果 小结1、Shell是什么 12是命令, 类似windows的dos命令又是一门程序设计语言, 里面含有变量, 函数, 逻辑控制语句等 2、Shell脚本是什么 1是一个文本文件, 里面可以编写Shell命令或进行编程, 形成一个可重用执行的脚本文件 3、shell脚本的作用 1通过shell编程提高对linux系统管理工作效率 4、linux系统默认的shell解析器 1/bin/bash Shell脚本入门：编写格式与执行方式目标1、掌握shell脚本编写规范 2、掌握执行shell脚本文件的3种方式与区别 Shell脚本文件编写规范脚本文件后缀名规范shell脚本文件就是一个文本文件, 后缀名建议使用 .sh 结尾 首行格式规范首行需要设置Shell解析器的类型, 语法 1#!/bin/bash 含义: 设置当前shell脚本文件采用bash解析器运行脚本代码 注释格式单行注释, 语法 1# 注释内容 多行注释, 语法 1234:&lt;&lt;!# 注释内容1# 注释内容2! shell脚本HelloWord入门案例需求创建一个Shell脚本文件helloworld.sh，输出hello world字符串 效果 实现步骤1、创建shell脚本文件 1touch helloworld.sh 2、编辑文件 1vim helloworld.sh 3、增加shell脚本文件内容如下，并保存退出 12#!/bin/bashecho &quot;hello world&quot; 4、执行脚本 1sh helloworld.sh 运行效果 脚本文件的常用执行3种方式介绍 sh解析器执行方式 语法: sh 脚本文件 介绍: 就是利用sh命令执行脚本文件, 本质就是使用Shell解析器运行脚本文件 bash解析器执行方式 语法: bash 脚本文件 介绍: 就是利用bash命令执行脚本文件, 本质就是使用Shell解析器运行脚本文件 仅路径执行方式 语法: ./脚本文件 介绍: 执行当前目录下的脚本文件 注意: 脚本文件自己执行需要具有可执行权限, 否则无法执行 3种方式的区别​ sh或bash执行脚本文件方式是直接使用Shell解析器运行脚本文件, 不需要可执行权限 ​ 仅路径方式是执行脚本文件自己, 需要可执行权限 执行脚本方式1-sh命令执行相对路径效果 1sh helloworld.sh 绝对路径效果 1sh /root/helloworld.sh 执行脚本方式2-bash命令执行相对路径效果 绝对路径效果 执行脚本方式3-仅路径执行语法步骤1：设置所有用户对此脚本文件增加可执行性权限 1chmod a+x 脚本文件 步骤2：执行脚本语法 1脚本文件的相对路径或绝对路径 示例：使用仅路径方式执行helloworld.sh脚本文件添加执行权限 1chmod a+x helloworld.sh 相对路径执行命令 1./helloworld.sh 相对路径执行效果 绝对路径执行命令 1/root/helloworld.sh 绝对路径执行效果 小结1、shell脚本文件编写规范？ ​ 文件的后缀名: 建议使用 .sh 扩展名 ​ 首行需要设置解析器类型 #!/bin/bash ​ 脚本文件中的注释 ​ 单行注释, # 注释内容 ​ 多行注释 :&lt;&lt;! ​ # 注释内容 ​ ! 2、执行shell脚本文件有哪3种方式，并说明他们的区别？ sh执行脚本文件 bash执行脚本文件 仅路径执行脚本文件 区别: 前2种是解析器直接执行不需要可执行权限, 最后一种是脚本文件自己执行需要可执行权限 Shell脚本入门：多命令处理目标掌握shell脚本文件中执行多命令处理 多命令处理介绍就是在Shell脚本文件中编写多个Shell命令 案例需求已知目录/root/itheima目录，执行batch.sh脚本，实现在/root/itheima/目录下创建一个one.txt,在one.txt文件中增加内容“Hello Shell”。 步骤分析 使用mkdir创建/root/itheima目录 创建脚本文件batch.sh 编辑脚本文件 3.1 命令1: touch创建文件, 文件名 /root/itheima/one.txt 3.2 命令2: 输出数据”Hello Shell”到one.txt文件中 输出数据到文件中的命令: 数据 &gt;&gt; 文件 执行脚本文件 实现步骤1、进入root目录，执行创建/root/itheima目录命令 1mkdir /root/itheima 2、创建/root/batch.sh文件 1touch batch.sh 2、编辑batch.sh文件，编写shell命令 1vim batch.sh 3、编写命令 命令1：创建/root/itheima/one.txt文件 命令2：输出“I love Shell”字符串数据到one.txt文件中 1234#!/bin/bashcd itheima # 切换到itheima目录touch one.txt # 创建文件one.txtecho &quot;Hello Shell&quot;&gt;&gt;/root/itheima/one.txt #输出数据到one.txt文件中 运行脚本效果运行batch.sh脚本文件 1sh batch.sh 查看one.txt文件内容 1cat itheima/one.txt 小结shell脚本文件中是否可以执行多命令处理？ 可以 Shell变量：环境变量目标1、理解什么是系统环境变量？ 2、掌握常用的系统环境变量都有哪些？ Shell变量的介绍变量用于存储管理临时的数据, 这些数据都是在运行内存中的. 变量类型 系统环境变量 自定义变量 特殊符号变量 系统环境变量介绍是系统提供的共享变量.是linux系统加载Shell的配置文件中定义的变量共享给所有的Shell程序使用 Shell的配置文件分类1.全局配置文件/etc/profile/etc/profile.d/*.sh/etc/bashrc 2.个人配置文件当前用户/.bash_profile当前用户/.bashrc 一般情况下，我们都是直接针对全局配置进行操作。 环境变量分类在Linux系统中，环境变量按照其作用范围不同大致可以分为系统级环境变量和用户级环境变量。 系统级环境变量：Shell环境加载全局配置文件中的变量共享给所有用户所有Shell程序使用, 全局共享用户级环境变量：Shell环境加载个人配置文件中的变量共享给当前用户的Shell程序使用, 登录用户使用 查看当前Shell系统环境变量查看命令 1env 效果 查看Shell变量(系统环境变量+自定义变量+函数)命令 1set 效果 常用系统环境变量 变量名称 含义 ==PATH== 与windows环境变量PATH功能一样，设置命令的搜索路径，以冒号为分割 HOME 当前用户主目录：/root SHELL 当前shell解析器类型：/bin/bash ==HISTFILE== 显示当前用户执行命令的历史列表文件：/root/.bash_history PWD 显示当前所在路径：/root OLDPWD 显示之前的路径 HOSTNAME 显示当前主机名：itheima HOSTTYPE 显示主机的架构，是i386、i686、还是x86、x64等：x86_64 ==LANG== 设置当前系统语言环境：zh_CN.UTF-8 环境变量输出演示 小结1.系统环境变量是什么? 是系统提供的环境变量, 通过加载Shell配置文件中变量数据共享给Shell程序使用 2.环境变量的分类? 系统级环境变量, Shell环境加载全局配置文件中定义的变量 用户级环境变量, Shell环境加载个人配置文件中定义的变量 3.env与set区别 env用于查看系统环境变量 set用于查看系统环境变量+自定义变量+函数 4.常用环境变量 变量名称 含义 PATH 命令搜索的目录路径, 与windows的环境变量PATH功能一样 LANG 查询系统的字符集 HISTFILE 查询当前用户执行命令的历史列表 Shell变量：自定义变量目标理解自定义变量的分类 能够自定义变量进行增\\删\\改\\查 自定义变量介绍就是自己定义的变量 分类 自定义局部变量 自定义常量 自定义全局变量 自定义局部变量介绍就是定义在一个脚本文件中的变量, 只能在这个脚本文件中使用的变量, 就是局部变量 定义与使用定义语法 1var_name=value 变量定义规则 变量名称可以有字母,数字和下划线组成, 但是不能以数字开头 等号两侧不能有空格 在bash环境中, 变量的默认类型都是字符串类型, 无法直接进行数值运算 变量的值如果有空格, 必须使用双引号括起来 不能使用Shell的关键字作为变量名称 演示 查询变量值语法 12345# 语法1: 直接使用变量名查询$var_name# 语法2: 使用花括号$&#123;var_name&#125;# 区别: 花括号方式适合拼接字符串 演示 注意: 如果&quot;My name is $&#123;var2&#125;Style&quot; 中 $var2 不带花括号, 系统会认为获取$var2Style 变量数据, 这个变量不存在就获取不到数据,执行效果如下 结论: 推荐大家使用花括号才是编程好习惯 变量删除语法 1unset var_name 演示 自定义常量介绍 就是变量设置值以后不可以修改的变量叫常量, 也叫只读变量 语法 1readonly var_name 演示 自定义全局变量父子Shell环境介绍例如: 有2个Shell脚本文件 A.sh 和 B.sh 如果 在A.sh脚本文件中执行了B.sh脚本文件, 那么A.sh就是父Shell环境, B.sh就是子Shell环境 自定义全局变量介绍 就是在当前脚本文件中定义全局变量, 这个全局变量可以在当前Shell环境与子Shell环境中都可以使用 自定义全局变量语法1export var_name1 var_name2 案例需求测试全局变量在子Shell中是否可用, 在父Shell中是否可用 案例实现步骤 创建2个脚本文件 demo2.sh 和 demo3.sh 编辑demo2.sh 命令1:定义全局变量VAR4 命令2: 执行demo3.sh脚本文件 编辑demo3.sh 输出全局变量VAR4 执行demo2.sh脚本文件 案例演示 创建demo2.sh和demo3.sh文件 编辑demo2.sh, 里面定义变量VAR4并设置为全局, 并里面执行demo3.sh脚本文件 1vim demo2.sh 编辑demo3.sh, 里面打印VAR4 1vim demo3.sh 执行脚本文件demo2.sh, 观察打印VAR4效果 执行脚本文件后, 在交互式Shell环境打印VAR4, 观察打印VAR4效果 结论全局变量在当前Shell环境与子Shell环境中可用, 父Shell环境中不可用 小结自定义变量的分类 自定义局部变量: 就是在一个脚本文件内部使用 var_name=value 自定义常量: 不可以修改值的变量, readonly var_name 自定义全局变量: 设置变量在当前脚本文件中与子Shell环境可以使用的变量, export var_name 自定义变量进行增\\删\\改\\查 定义和修改: var_name=value 查询:$&#123;var_name&#125; 或 $var_name 删除: unset var_name Shell变量：特殊变量目标能够说出常用的特殊变量有哪些 特殊变量：$n语法1$n 含义1234用于接收脚本文件执行时传入的参数$0 用于获取当前脚本文件名称的$1~$9, 代表获取第一输入参数到第9个输入参数第10个以上的输入参数获取参数的格式: $&#123;数字&#125;, 否则无法获取 执行脚本文件传入参数语法1sh 脚本文件 输入参数1 输入参数2 ... 案例需求创建脚本文件demo4.sh文件, 并在脚本文件内部执行打印脚本文件名字, 第一个输入参数, 第二个输入参数 实现步骤 创建脚本文件demo4.sh 编辑demo4.sh的文件内容 1234# 命令1: 打印当前脚本文件名字# 命令2: 打印第1个输入参数# 命令3: 打印第2个输入参数# 命令4: 打印第10个输入参数 执行脚本文件demo4.sh 演示 创建demo4.sh文件 编辑demo4.sh文件, 输出脚本文件名称\\第一个输入参数\\第二个输入参数 执行demo4.sh文件,输入输出参数itcast itheima的2个输入参数, 观察效果 特殊变量：$#语法 1$# 含义获取所有输入参数的个数 案例需求在demo4.sh中输出输入参数个数 演示编辑demo4.sh, 输出输入参数个数 执行demo4.sh传入参数itcast, itheima, 播仔 看效果 特殊变量：$*、$@语法123$*$@# 含义都是获取所有输入参数, 用于以后输出所有参数 $*与$@区别 1234561.不使用双引号括起来, 功能一样 $*和$@获取所有输入参数,格式为: $1 $2 ... $n2.使用双引号括起来 &quot;$*&quot;获取的所有参数拼接为一个字符串, 格式为: &quot;$1 $2 ... $n&quot; &quot;$@&quot;获取一组参数列表对象, 格式为: &quot;$1&quot; &quot;$2&quot; ... &quot;$n&quot; 使用循环打印所有输入参数可以看出区别 循环语法 1234for var in 列表变量do # 循环开始 命令 # 循环体done # 循环结束 案例需求在demo4.sh中循环打印输出所有输入参数, 体验$*与$@的区别 实现步骤编辑demo4.sh脚本文件 12# 增加命令: 实现直接输出所有输入后参数# 增加命令: 使用循环打印输出所有输入参数 演示 编辑demo4.sh文件 直接输出所有输入参数, 与循环方式输出所有输入参数(使用双引号包含 $* 与 $@ ) 123456789101112131415161718192021222324252627282930313233#!/bin/bash# 命令1: 打印当前脚本文件名字echo &quot;当前脚本文件名称:$0&quot;# 命令2: 打印第1个输入参数echo &quot;第一个输入参数:$1&quot;# 命令3: 打印第2个输入参数echo &quot;第二个输入参数:$2&quot;# 命令4: 打印第10个输入参数echo &quot;第十个输入参数不带花括号获取:$10&quot;echo &quot;第十个输入参数带花括号获取:$&#123;10&#125;&quot;# 命令5 打印所有输入参数的个数echo &quot;所有输入参数个数:$&#123;#&#125;&quot;# 增加命令: 实现直接输出所有输入后参数echo &#x27;使用$*直接输出:&#x27;$*echo &#x27;使用$@直接输出:&#x27;$@# 增加命令: 使用循环打印输出所有输入参数echo &#x27;循环遍历输出$*所有参数&#x27;for item in &quot;$*&quot;do echo $itemdoneecho &#x27;循环遍历输出$@所有参数&#x27;for item in &quot;$@&quot;do echo $itemdone 运行观察区别 特殊变量：$？语法1$? 含义用于获取上一个Shell命令的退出状态码, 或者是函数的返回值 每个Shell命令的执行都有一个返回值, 这个返回值用于说明命令执行是否成功 一般来说, 返回0代表命令执行成功, 非0代表执行失败 演示输入一个正确命令, 再输出$? 输入一个错误命令, 在输出$? 特殊变量：$$语法1$$ 含义用于获取当前Shell环境的进程ID号 演示查看当前Shell环境进程编号 1ps -aux|grep bash 输出 $$ 显示当前shell环境进程编号 小结常用的特殊符号变量如下 特殊变量 含义 $n 获取输入参数的$0, 获取当前Shell脚本文件名字$1~$9, 获取第一个输入参数到第九个输入参数$&#123;10&#125; 获取10和10以上的参数需要使用花括号 $# 获取所有输入参数的个数 $* 与 $@ 获取所有输入参数数据区别: 如果不使用双引号, 功能一样, 获取所有参数数据为一个字符串, 如果使用了双引号, $@获取的就是参数列表对象, 每个参数都是一个独立字符串, $? 获取上一个命令的退出状态码, 一般;来说0代表命令成功, 非0代表执行失败 $$ 获取当前shell环境进程的ID号 Shell环境变量深入：自定义系统环境变量目标能够自定义系统级环境变量 全局配置文件/etc/profile应用场景当前用户进入Shell环境初始化的时候会加载全局配置文件/etc/profile里面的环境变量, 供给所有Shell程序使用 以后只要是所有Shell程序或命令使用的变量, 就可以定义在这个文件中 案例演示需求/etc/profile定义存储自定义系统级环境变量数据 创建环境变量步骤 编辑/etc/profile全局配置文件 12# 增加命令: 定义变量VAR1=VAR1 并导出为环境变量# 扩展: vim里面的命令模式使用G快速定位到文件末尾位置, 使用gg定位到文件首行位置 重载配置文件/etc/profile, 因为配置文件修改后要立刻加载里面的数据就需要重载, 语法 1source /etc/profile 在Shell环境中读取系统级环境变量VAR1 创建环境变量演示编辑/etc/profile文件 1vim /etc/profile 添加设置变量VAR1=VAR1并导出成为环境变量, 在/etc/profile文件末尾添加如下命令 123# 创建环境变量VAR1=VAR1export VAR1 3、保存/etc/profile退出 4、重新加载/etc/profile文件数据更新系统环境变量 1source /etc/profile 注意：如果这一步不执行，无法读取更新的环境变量 3、输出环境变量VAR1 1echo $VAR1 小结如何自定义系统级环境变量 系统级全局配置文件: /etc/profile 设置环境变量: export var_name=value, 注意环境变量建议变量名全部大写 修改了/etc/profile文件后, 要立刻加载修改的数据需要重载配置文件: source /etc/profile Shell环境变量深入：加载流程原理介绍目标 能够说出交互式Shell与非交互式Shell 能够说出登录Shell与非登录Shell环境 Shell工作环境介绍用户进入linux系统就会初始化Shell环境, 这个环境会加载全局配置文件和用户个人配置文件中环境变量.每个脚本文件都有自己的Shell环境 shell工作环境分类交互式与非交互式shell交互式Shell 与用户进行交互, 互动. 效果就是用户输入一个命令, Shell环境立刻反馈响应. 非交互式Shell 不需要用户参与就可以执行多个命令. 比如一个脚本文件含有多个命令,直接执行并给出结果 登录Shell与非登录Shell环境 类型名称 含义 shell登录环境 需要用户名\\密码登录的Shell环境 shell非登录环境 不需要用户名,密码进入的Shell环境 或 执行脚本文件 注意：不同的工作环境加载环境变量流程不一样 环境变量初始化流程1.全局配置文件/etc/profile/etc/profile.d/*.sh/etc/bashrc 2.个人配置文件当前用户/.bash_profile当前用户/.bashrc 环境变量加载初始化过程 小结 能够说出交互式Shell与非交互式Shell 交互式Shell: 就是需要用户参与互动的Shell环境, 效果用户输入一个命令, 环境就立刻响应结果 非交互式Shell: 只执行命令, 不需要用户的参与 能够说出登录Shell与非登录Shell环境 登录Shell环境: 要以用户名与密码登录到系统默认采用登录Shell环境 非登录Shell环境: 不实用用户名与密码进入linux系统的Shell环境 Shell环境变量深入：加载流程测试目标理解Shell环境变量的加载流程测试 能够知道环境变量应该配置在哪里 切换Shell环境执行脚本文件介绍在执行一个脚本文件时可以指定具体Shell环境进行执行脚本文件, 这个就是切换Shell环境执行脚本 Shell登录环境执行脚本文件语法1sh/bash -l/--login 脚本文件 含义: 先加载Shell登录环境流程初始化环境变量, 再执行脚本文件 Shell非登录环境变量执行脚本文件语法12bash # 加载Shell非登录环境sh/bash 脚本文件 # 直接执行脚本文件 含义: 先执行加载Shell非登录环境流程初始化环境变量, 再执行脚本文件 测试案例需求Shell登录环境会运行/etc/profile Shell非登录环境会运行/.bashrc 在/etc/profile与/当前用户/.bashrc文件分别设置环境变量数据，然后在shell脚本文件中输出环境变量数据，最后切换不同环境执行shell脚本文件观察验证上面的流程运行 分析 清理工作, 清理/etc/profile文件中VAR1环境变量进行删除, 并且重载这个配置文件 编辑/etc/profile, 增加环境变量VAR1=VAR1 编辑/root/.bashrc, 增加环境变量VAR2=VAR2 创建demo1.sh文件, 读取环境变量数据进行打印 12# 输出环境变量VAR1# 输出环境变量VAR2 以Shell非登录环境执行demo1.sh脚本文件, 观察只会输出VAR2, 不会输出VAR1 以Shell登录环境执行demo1.sh脚本文件, 观察会输出VAR2和VAR1 演示编辑/etc/profile文件 1vim /etc/profile 编辑添加如下内容，保存退出 在root目录下,编辑.bashrc文件 1vim .bashrc 编辑添加如下最后2行内容，保存退出 创建文件demo1.sh 1touch demo1.sh 编辑文件demo1.sh，添加如下内容 直接执行脚本文件 1bash demo1.sh 直接执行脚本文件, 即没有加载登录Shell环境变量, 也没有加载非登录Shell环境变量 先加载非登录Shell环境变量, 然后执行脚本文件 12bashbash demo1.sh Shell非登录环境会加载文件 当前用户/.bashrc 的环境变量数据 所以这里会输出VAR2的环境变量数据 先加载登录Shell环境变量, 然后执行脚本文件 1bash -l demo1.sh Shell登录环境会加载文件 etc/profile和当前用户/.bashrc 的环境变量数据 所以这里会输出VAR1和VAR2的环境变量数据 小结1、Shell环境变量初始化加载原理过程 分类 初始化环境变量过程执行文件顺序 shell登录环境初始化过程 /etc/profile–》/etc/profile.d/*.sh–》/.bash_profile–》/.bashrc–》/etc/bashrc shell非登录环境初始化过程 ~/.bashrc–》/etc/bashrc–》/etc/profile.d/*.sh 2、那么以到底将环境变量定义到哪里呢？/etc/profile与/etc/bashrc的区别？ 需要登录的执行的shell脚本读取的环境变量配置在：/etc/profile、/当前用户/.bash_profile 不需要登录的用户执行的shell脚本读取的环境变量配置在：/当前用户/.bashrc、/etc/bashrc Shell环境变量深入：识别Shell环境类型目标理解如何识别shell登录环境与非登录环境 语法使用$0识别环境语法 1echo $0 输出 -bash 代表：shell登录环境 输出 bash 代表： shell非登录环境 注意：这个 $0 环境变量如果用在子shell中(shell脚本文件)输出Shell脚本本身的文件名 bash命令语法 1bash bash命令：用于切换为Shell非登录环境 分析1、直接登录系统为shell登录环境输出 $0 观察输出信息效果 2、使用 bash 命令切换为shell非登录环境输出 $0 观察输出信息效果 3、创建test.sh脚本文件，编辑添加输出 $0 ,编程保存完成后执行test.sh脚本文件观察输出信息效果 演示直接登录linux系统使用如下命令效果 bash命令将当前环境转换为Shell非登录环境 小结1、如何识别shell登录环境与非登录环境？ 12$0 用于获取当前Shell环境的类型, bash代表Shell非登录环境, -bash 代表Shell登录环境# $0不可以在脚本文件中使用, 因为代表获取脚本文件名字 Shell环境变量深入：详细切换Shell环境目标理解切换shell环境的命令 切换shell环境命令介绍 直接登录加载shell登录环境 su切换用户加载Shell登录与Shell非登录环境 bash加载Shell登录与Shell非登录环境 切换Shell环境命令演示切换环境方式1：直接登录系统介绍直接在虚拟机上使用用户名与密码登录linux系统或使用客户端直接连接远程linux系统 演示虚拟机本地直接登录演示 客户端远程采用SSH登录演示 切换环境方式2：su切换用户登录命令语法1 1234su 用户名 --login 或su 用户名 -l # 切换到指定用户, 加载Shell登录环境变量 语法2 12su 用户名 # 切换到指定用户, 加Shell非登录环境变量 分析步骤1、创建普通用户userA 2、切换到用户userA，使用-l加载Shell登录环境变量 , 输出环境变量$0，观察输出-bash 4、使用exit退出userA 5、切换到用户userA，加载Shell非登录环境变量，输出环境变量$0，观察输出bash 演示创建普通用户userA 1useradd -m userA 以Shell登录环境执行切换到用户userA，输出环境变量$0，输出 -bash 说明当前为Shell登录环境 使用exit退出userA 以Shell非登录环境执行切换到用户userA，输出环境变量$0，输出 bash 说明当前为Shell非登录环境 切换环境方式3：bash切换命令语法1: 1bash # 加载【Shell非登录环境】 语法2： 123bash -l Shell脚本文件 / bash --login shell脚本文件sh -l shell脚本文件 / sh --login shell脚本文件# 先加载【Shell登录环境】然后运行指定Shell脚本文件 分析使用bash执行test.sh脚本文件，发生错误说明当前环境为Shell非登录环境 演示","categories":[{"name":"运维","slug":"运维","permalink":"http://liujun1997.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Linux Shell","slug":"Linux-Shell","permalink":"http://liujun1997.github.io/tags/Linux-Shell/"}]},{"title":"树莓派常用操作","slug":"树莓派常用操作","date":"2021-08-21T07:39:55.000Z","updated":"2022-04-23T12:25:27.943Z","comments":true,"path":"2021/08/21/树莓派常用操作/","link":"","permalink":"http://liujun1997.github.io/2021/08/21/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"蓝牙常用命令 查看蓝牙开启状态 1systemctl status bluetooth 进入蓝牙终端程序命令 1bluetoothctl 扫描周围蓝牙设备 1scan on 匹配设备 1pair xx:xx:xx:xx 信任设备 1trust xx:xx:xx:xx 连接设备 1connect xx:xx:xx:xx 常见问题 当匹配的时候出现 alreadyExist Error时，并且连接不上时，可以先移除设备再匹配 1234remove xx:xx:xx:xx //移除设备pair xx:xx:xx:xxtrust xx:xx:xx:xxconnect .... Wifi常用命令 当我们没有图形化界面去配置wifi设置时，就只能通过命令行设置wifi 可以使用命令先扫描周围的Wi-Fi名 iwlist wlan0 scan 编辑系统wifi配置文件，vim /etc/wpa_supplicant/wpa_supplicant.conf 在最后一行写入wifi的SSID信息和密码，如下 12345678root@raspberrypi:vim /etc/wpa_supplicant/wpa_supplicant.conf network=&#123; ssid=&quot;WiFi-A&quot; //Wi-Fi名 psk=&quot;12345678&quot; //密码 key_mgmt=WPA-PSK //密码认证方式 priority=1 //数值越大，优先级越高&#125; 重启wifi配置 12root@raspberrypi:wpa_cli -i wlan0 reconfigure //重新配置wifi root@raspberrypi:wpa_cli -i wlan0 reconnect // 重新连接wifi 查看是否连接上wifi 1root@raspberrypi:ifconfg wlan0 //查看无线网卡是否有下图ip 有时候也需要给树莓派设置固定ip, 编辑/etc/dhcpcd .conf，写入下面配置 123456# Example static IP configuration: interface wlan0 # 表示给某个接口 eth0代表有线网卡，wlan代表无线static ip_address=192.168.10.105/24 # ipv4固定ipstatic ip6_address=fd51:42f8:caae:d92e::ff/64 # ipv6固定ipstatic routers=192.168.10.1 # 路由地址static domain_name_servers=192.168.10.1 8.8.8.8 fd51:42f8:caae:d92e::1 # DNS服务器 树莓派挂载磁盘命令 首先将u盘插入树莓派usb接口，然后使用命令 fdisk -l查看系统是否已经识别 我这里是mac的hdf文件类型移动硬盘，如果挂载后是不可写，需要下载软件挂载 1sudo apt-get install hfsplus hfsutils hfsprogs 挂载hfs分区 123456sudo mkdir /tmsudo chown -R nobody:nogroup /tmsudo mount -t hfsplus -o force,rw /dev/sda2 /tm# 如果想卸载，可以采用此命令 sudo umount -v /dev/sda2 挂载ntfs分区，树莓派不支持直接挂载ntfs文件系统的外置硬盘 1sudo apt-get install ntfs-3g ## 安装第三方驱动包 挂载exfat分区,也需要安装额外的第三方驱动包，相比于ntfs文件系统，实测exfat文件系统在树莓派上读写速度更快，查询资料是因为 ntfs-3g驱动效率太低，不太建议在linux系统上使用ntfs文件格式外置硬盘 1sudo apt-get install exfat-fuse 设置开机挂载, 需要编辑/etc/fstab文件，在最后一行添加一下内容 1/dev/sda2 /data hfsplus force,rw,auto 0 0 如果想用树莓派做一个timemachine 可以参考一下blog 有时候需要测试磁盘的read write速度,需要用上下面两条命令 123456789# 这是我电脑上的挂载情况root@raspberrypi:~# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 465.8G 0 disk ├─sda1 8:1 0 200M 0 part └─sda2 8:2 0 465.5G 0 part /datammcblk0 179:0 0 14.9G 0 disk ├─mmcblk0p1 179:1 0 256M 0 part /boot└─mmcblk0p2 179:2 0 14.6G 0 part / 12345# 使用dd测试移动磁盘的读取速度root@raspberrypi:~# dd if=/dev/zero of=/data/test.db bs=8k count=50000 conv=fdatasync记录了50000+0 的读入记录了50000+0 的写出409600000 bytes (410 MB, 391 MiB) copied, 4.07416 s, 101 MB/s 12345# 测试写入速度root@raspberrypi:~# dd if=/dev/sda2 of=/dev/null bs=8k count=50000记录了50000+0 的读入记录了50000+0 的写出409600000 bytes (410 MB, 391 MiB) copied, 3.61052 s, 113 MB/s 树莓派软件常用命令 更换软件源为国内的软件源 编辑 /etc/apt/suorces.list文件，将里面的文字注释掉，添加以下文件 123root@raspberrypi:~# cat /etc/apt/sources.listdeb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contribdeb-src https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib 编辑/etc/apt/sources.list.d文件，更改为 12345root@raspberrypi:/etc/apt/sources.list.d# cat raspi.listdeb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui#deb https://archive.raspberrypi.org/debian/ buster main# Uncomment line below then &#x27;apt-get update&#x27; to enable &#x27;apt-get source&#x27;# deb-src https://archive.raspberrypi.org/debian/ buster main 然后在更新软件缓存 1root@raspberrypi:/etc/apt/sources.list.d# sudo apt-get update 树莓派安装samba服务器，实现文件共享 第一步安装samba服务器 sudo apt-get install samba -y 编辑配置文件 sudo vim /etc/samba/smb.conf，在文件末尾添加以下配置， 123456[pi]path = /media/data #文件目录路径writeable=Yes # 可写create mask=0777 #文件权限directory mask=0777 #目录权限public=no #不为公共 优化传输读写速度 ,sudo vim /etc/samba/smb.conf,在 global节点添加以下配置 12345678910111213 security=user ## 表示需要用户密码验证 如果为share则不需要 #increase speed max connections = 5 socket options = TCP_NODELAY IPTOS_LOWDELAY SO_RCVBUF=65536 SO_SNDBUF=65536 read raw = yes write raw = yes#此选项在新版本无效# read size = 65536 write cache size = 262144 aio read size = 16384 aio write size = 16384 large readwrite = yes 配置samba用户名 12useradd #添加系统用户，不添加后面的操作会报错smbpasswd -a &lt;username&gt; #按照提示输入用户名 启动服务器 systemctl start smbd","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://liujun1997.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派 网络","slug":"树莓派-网络","permalink":"http://liujun1997.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE-%E7%BD%91%E7%BB%9C/"}]},{"title":"Linux自动删除日志","slug":"Linux自动删除日志","date":"2021-08-17T03:28:46.000Z","updated":"2021-08-17T06:12:11.000Z","comments":true,"path":"2021/08/17/Linux自动删除日志/","link":"","permalink":"http://liujun1997.github.io/2021/08/17/Linux%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4%E6%97%A5%E5%BF%97/","excerpt":"","text":"背景 最近定时任务调度平台的日志比较多，经过长期的日积月累，终于磁盘的空间终于爆了，业务系统也瘫痪了，所以需要定时无用的日志。 分析 google后，发现有两种解决方法 通过find 命令解决1find $&#123;dirname&#125; -name &quot;*.log&quot; -mtime $&#123;day&#125; -exec rf -rf &#123;&#125; \\; 通过递归遍历文件夹的文件，比较文件的创建时间，进行删除 比较发现还是第一种比较方便 实践 命令解析 find 对应目录 -mtime +天数 -name “文件名” -exec rm -rf {} ; 实际命令 1find /etc/nginx/log -mtime +30 -name &#x27;*.log&#x27; -exec rm -rf &#123;&#125; \\; 再优化一下 新建脚本文件 vim autoDeleteLog.sh 123456789#!/bin/bashfindDir=&#x27;/etc/nginx/log&#x27;if [ -d &quot;$&#123;findDir&#125;&quot;]; then echo start delete log file 30 day ago... find /etc/nginx/log -mtime +30 -name &#x27;*.log&#x27; -exec rm -rf &#123;&#125; \\; echo delete log file end...else echo $&#123;findDir&#125; not find...fi 给脚本加上权限 chmod +x autoDeleteLog.sh 设置为定时任务执行 12$bin: crontab -e0 0 * * * /home/autoDeleteLog.sh","categories":[{"name":"运维","slug":"运维","permalink":"http://liujun1997.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://liujun1997.github.io/tags/Linux/"}]},{"title":"Cron表达式解析","slug":"Cron表达式解析","date":"2021-08-10T07:30:42.000Z","updated":"2021-08-10T09:52:04.000Z","comments":true,"path":"2021/08/10/Cron表达式解析/","link":"","permalink":"http://liujun1997.github.io/2021/08/10/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Corn表达式解析1.概念 cron是表示定时任务执行规律的一串字符串，通常由5/6个字符隔开，用6，7个域表示。每个域由以下几种字符组成 * 表示任意值都满足条件。 ,表示选定的几个值满足条件。秒域1,5，表示 在1秒和5秒之间触发 -表示范围，秒域1,5表示 ，在1秒与5秒之间触发每一秒到触发 /表示在某个时间起，每隔固定的时间执行一次，秒域0/5表示从0秒开始，每隔5秒触发，5，10，15秒都会触发。秒域*/5表示从执行开始，每隔5s触发一次。比如执行的时候是第3s，则8，13秒都会触发。 ?表示在两个可能的矛盾字段中，忽略其中一个字段的值。通常是用在 dayofweek和dayofmouth这两个字段中，只能用一次。 L 表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 W 表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。 LW 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 # 表示每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。 2.字段含义 字段 允许值 允许的特殊字符 秒（Seconds） 0~59的整数 , - * / 四个字符 分（Minutes） 0~59的整数 , - * / 四个字符 小时（Hours） 0~23的整数 , - * / 四个字符 日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? / L W C 八个字符 月份（Month） 1~12的整数或者 JAN-DEC , - * / 四个字符 星期（DayofWeek） 1~7的整数或者 SUN-SAT （1=SUN） , - * ? / L C # 八个字符 3.常见的域12345678910111213141516171819202122232425262728293031323334353637383940414243（1） 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务 （2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业 （3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 （4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 （5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 （6）0 0 12 ? * WED 表示每个星期三中午12点 （7）0 0 12 * * ? 每天中午12点触发 （8）0 15 10 ? * * 每天上午10:15触发 （9）0 15 10 * * ? 每天上午10:15触发 （10）0 15 10 * * ? * 每天上午10:15触发 （11）0 15 10 * * ? 2005 2005年的每天上午10:15触发 （12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 （13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 （14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 （15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 （16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 （17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 （18）0 15 10 15 * ? 每月15日上午10:15触发 （19）0 15 10 L * ? 每月最后一日的上午10:15触发 （20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 （21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 （22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发","categories":[{"name":"Linux","slug":"Linux","permalink":"http://liujun1997.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://liujun1997.github.io/tags/Linux/"},{"name":"Java","slug":"Java","permalink":"http://liujun1997.github.io/tags/Java/"}]},{"title":"物联网","slug":"物联网","date":"2021-08-07T06:44:17.000Z","updated":"2021-09-05T05:44:36.000Z","comments":true,"path":"2021/08/07/物联网/","link":"","permalink":"http://liujun1997.github.io/2021/08/07/%E7%89%A9%E8%81%94%E7%BD%91/","excerpt":"","text":"一. 接入流程![image-20201222171458788](/Users/mac/Library/Application Support/typora-user-images/image-20201222171458788.png) 二.系统开发说明1.1 名词解析 产品: 对某一型设备的分类,通常是已经存在的某一个设备型号. 设备：具体的某一个设备. 网络组件: 用于管理各种网络服务(MQTT,TCP等),动态配置,启停. 只负责接收,发送报文,不负责任何处理逻辑。 协议: 用于自定义消息解析规则,用于认证、将设备发送给平台报文解析为平台统一的报文，以及处理平台下发给设备的指令。 设备网关: 负责平台侧统一的设备接入,使用网络组件处理对应的请求以及报文,使用配置的协议解析为平台统一的设备消息。 1.3 平台统一设备消息定义 平台使用自定义的协议包将设备上报的报文解析为平台统一的消息,来进行统一管理。 平台统一消息基本于物模型中的定义相同,主要由属性(property),功能(function),事件(event)组成. 1.2 消息组成 消息主要由deviceId,messageId,headers,timestamp组成. 1.3 属性相关消息 获取设备属性(ReadPropertyMessage)对应设备回复的消息ReadPropertyMessageReply. 设备上报属性(ReportPropertyMessage) 由设备上报. 1234567891011121314151617181920212223ReadPropertyMessage&#123; Map&lt;String,Object&gt; headers; String deviceId; String messageId; long timestamp; //时间戳(毫秒) List&lt;String&gt; properties;//可读取多个属性&#125;ReadPropertyMessageReply&#123; Map&lt;String,Object&gt; headers; String deviceId; String messageId; long timestamp; //时间戳(毫秒) boolean success; Map&lt;String,Object&gt; properties;//属性键值对&#125;ReportPropertyMessage&#123; Map&lt;String,Object&gt; headers; String deviceId; String messageId; long timestamp; //时间戳(毫秒) Map&lt;String,Object&gt; properties;&#125; 1.4 功能相关消息 调用设备功能到消息(FunctionInvokeMessage)由平台发往设备,对应到返回消息FunctionInvokeMessageReply 事件消息EventMessage由设备端发往平台. 12345678910111213141516171819202122FunctionInvokeMessage&#123; Map&lt;String,Object&gt; headers; String functionId;//功能标识,在元数据中定义. String deviceId; String messageId; long timestamp; //时间戳(毫秒) List&lt;FunctionParameter&gt; inputs;//输入参数&#125;FunctionParameter&#123; String name; Object value;&#125;FunctionInvokeMessageReply&#123; Map&lt;String,Object&gt; headers; String deviceId; String messageId; long timestamp; boolean success; Object output; //输出值,需要与元数据定义中的类型一致&#125; 1.5 事件相关消息 事件消息EventMessage由设备端发往平台. 123456EventMessage&#123; Map&lt;String,Object&gt; headers; String event; //事件标识,在元数据中定义 Object data; //与元数据中定义的类型一致,如果是对象类型,请转为java.util.HashMap,禁止使用自定义类型. long timestamp; //时间戳(毫秒)&#125; 1.6 其他相关消息 DeviceOnlineMessage 设备上线消息,通常用于网关代理的子设备的上线操作. DeviceOfflineMessage 设备上线消息,通常用于网关代理的子设备的下线操作. 123456EventMessage&#123; Map&lt;String,Object&gt; headers; String event; //事件标识,在元数据中定义 Object data; //与元数据中定义的类型一致,如果是对象类型,请转为java.util.HashMap,禁止使用自定义类型. long timestamp; //时间戳(毫秒)&#125; 二. 设备接入2.1 产品物模型定义 属性用于定义一些指标数据,如:电压,温度等. 属性都应该是简单的数据类型, 功能用于定义设备具有的一些可执行动作,如: 消音,关灯,云台控制.根据情况设计好输入参数和输出参数. 事件用于定义设备在特定条件时,发生的动作,如:火警,\b检测到人脸,通常为结构体类型,用于保存比较复杂的数据. 标签对于设备固有不变的信息,建议使用设备标签进行管理,如设备地理位置等. ![image-20201222173831786](/Users/mac/Library/Application Support/typora-user-images/image-20201222173831786.png) 2.2 协议包开发 协议是设备与平台通信的一种标准，某个设备想与平台进行通信就必须按照某种协议标准进行规定上报的数据格式，支持jar包形式 平台封装了网络通信,但是具体的数据由消息协议进行解析.协议(ProtocolSupport)主要由认证器(Authenticator), 消息编解码器(DeviceMessageCodec),消息发送拦截器(DeviceMessageSenderInterceptor)以及配置元数据(ConfigMetadata)组成 认证器(Authenticator)是用于在收到设备请求(例如MQTT)时,对客户端进行认证时使用,不同的网络协议(Transport)使用不同的认证器. 1234567891011121314151617181920212223public interface Authenticator &#123; /** * 对指定对设备进行认证 * * @param request 认证请求 * @param device 设备 * @return 认证结果 */ Mono&lt;AuthenticationResponse&gt; authenticate(@Nonnull AuthenticationRequest request, @Nonnull DeviceOperator device); /** * 在MQTT服务网关中指定了认证协议时,将调用此方法进行认证。 * 注意: 认证通过后,需要设置设备ID.&#123;@link AuthenticationResponse#success(String)&#125; * @param request 认证请求 * @param registry 设备注册中心 * @return 认证结果 */ default Mono&lt;AuthenticationResponse&gt; authenticate(@Nonnull AuthenticationRequest request, @Nonnull DeviceRegistry registry) &#123; return Mono.just(AuthenticationResponse.success()); &#125;&#125; 用于将平台统一的消息(Message)与设备端能处理的消息(EncodedMessage)进行相互转换. 设备网关从网络组件中接收到报文后,会调用对应协议包的消息编解码器进行处理. 不同网络协议需要转换为不同的EncodedMessage类型.比如,MQTT需要转换为MqttMessage. 12345678class DeviceMessageCodec&#123; //此编解码器支持的网络协议,如: DefaultTransport.MQTT Transport getSupportTransport(); //将平台发往设备的消息编码为设备端对消息 Publisher&lt;? extends EncodedMessage&gt; encode(MessageEncodeContext context); //将设备发往平台的消息解码为平台统一的消息 Publisher&lt;? extends Message&gt; decode(MessageDecodeContext context);&#125; EncodedMessage从网络组件中接收到的消息,不同的网络组件消息类型不同 1234567891011121314151617class EncodedMessage&#123; //获取原始报文 ByteBuf getPayload(); //报文转为字符串 String payloadAsString(); //报文转为JSON对象 JSONObject payloadAsJson(); //报文转为JSON数组 JSONArray payloadAsJsonArray(); // 报文转为字节数组 byte[] payloadAsBytes()&#125;//mqtt消息class MqttMessage extends EncodedMessage&#123; String getTopic(); int getQos();&#125; ConfigMetadata 配置元数据用于告诉平台,在使用此协议的时候,需要添加一些自定义配置到设备配置，(DeviceOperator.setConfig)中. 在其他地方可以通过DeviceOperator.getConfig获取这些配置. 123456789101112131415CompositeProtocolSupport support = new CompositeProtocolSupport();support.setId(&quot;demo-v1&quot;);support.setName(&quot;演示协议v1&quot;);support.setDescription(&quot;演示协议&quot;);support.setMetadataCodec(new ChiefLinksDeviceMetadataCodec()); //固定为JetLinksDeviceMetadataCodec,请勿修改.DefaultConfigMetadata mqttConfig = new DefaultConfigMetadata( &quot;MQTT认证配置&quot; , &quot;&quot;) .add(&quot;username&quot;, &quot;username&quot;, &quot;MQTT用户名&quot;, new StringType()) .add(&quot;password&quot;, &quot;password&quot;, &quot;MQTT密码&quot;, new PasswordType()) .add(&quot;productKey&quot;, &quot;productKey&quot;, &quot;产品密钥&quot;, new PasswordType(),DeviceConfigScope.product) //只有产品需要配置 ;//设置MQTT所需要到配置 support.addConfigMetadata(DefaultTransport.MQTT, mqttConfig); DeviceMessageSenderInterceptor 使用拦截器可以拦截消息发送和返回的动作 1234567DeviceMessageSenderInterceptor&#123; //发送前 Mono&lt;DeviceMessage&gt; preSend(DeviceOperator device, DeviceMessage message); //发送后 &lt;R extends DeviceMessage&gt; Flux&lt;R&gt; afterSent(DeviceOperator device, DeviceMessage message, Flux&lt;R&gt; reply);&#125; 2.3 创建对应的网关或者网络组件 选择 网络组件–&gt;组件管理–&gt; 点击新增组件按钮，新建对应的网络组件，在创建完成的模块上点击启动按钮 ![image-20201222173951304](/Users/mac/Library/Application Support/typora-user-images/image-20201222173951304.png) 选择 网络组件–&gt;设备网关–&gt; 点击新建按钮。在操作列点击启动按钮启动网关。 ![image-20201222174023253](/Users/mac/Library/Application Support/typora-user-images/image-20201222174023253.png) 2.4 创建设备实例 选择 设备管理–&gt;设备–&gt; 点击添加设备按钮，填写对应的信息添加 ![image-20201222173901028](/Users/mac/Library/Application Support/typora-user-images/image-20201222173901028.png) 2.5 设备调试 使用mqtfx工具模拟设备调试 三. 接入协议开发说明 平台支持mqtt协议，http协议，tcp协议，推荐使用mqtt协议，broker模式接入，平台提供一个此对接模式样例。 3.1 开发步骤 新建org.chieflinks.demo.protocol，创建协议编码解码类：DemoDeviceMessageCodec 123456789101112131415161718@AllArgsConstructor@Slf4jpublic class DemoDeviceMessageCodec implements DeviceMessageCodec &#123; @Override public Transport getSupportTransport() &#123; return DefaultTransport.Mqtt; &#125; @Override public Mono&lt;? extends Message&gt; decode(MessageDecodeContext context) &#123; return Mono.empty(); &#125; @Override public Publisher&lt;? extends EncodedMessage&gt; encode(MessageEncodeContext context) &#123; retrun Mono.empty(); &#125;&#125; 创建协议入口类： DemoProtocolSupportProvider 1234567891011121314public class DemoProtocolSupportProvider implements ProtocolSupportProvider &#123; @Override public Mono&lt;? extends ProtocolSupport&gt; create(ServiceContext context) &#123; CompositeProtocolSupport support = new CompositeProtocolSupport(); support.setId(&quot;xx&quot;); support.setName(&quot;xxx&quot;); support.setDescription(&quot;xxx&quot;); support.setMetadataCodec(new ChiefLinksDeviceMetadataCodec()); DemoDeviceMessageCodec codec = new DemoDeviceMessageCodec(); support.addMessageCodecSupport(DefaultTransport.Mqtt, () -&gt; Mono.just(codec)); return Mono.just(support); &#125; &#125; 消息上报解码 123456789101112@Overridepublic Mono&lt;? extends Message&gt; decode(MessageDecodeContext context) &#123; return Mono.fromSupplier(() -&gt; &#123; MqttMessage mqttMessage = (MqttMessage) context.getMessage(); String topic = mqttMessage.getTopic(); JSONObject payload = JSON.parseObject(mqttMessage.getPayload().toString(StandardCharsets.UTF_8)); String deviceId = context.getDevice() != null ? context.getDevice().getDeviceId() : null; return doDecode(deviceId, topic, payload); &#125;); &#125; 平台发送消息给设备(编码) 123456789101112131415161718192021222324public Mono&lt;EncodedMessage&gt; encode(MessageEncodeContext context) &#123; Message message = context.getMessage(); return Mono.defer(() -&gt; &#123; if (message instanceof DeviceMessage) &#123; if (message instanceof DisconnectDeviceMessage) &#123; return ((ToDeviceMessageContext) context) .disconnect() .then(Mono.empty()); &#125; TopicMessage msg = doEncode((DeviceMessage) message); if (null == msg) &#123; return Mono.empty(); &#125; return Mono.just(SimpleMqttMessage.builder() .topic(msg.getTopic()) .payload(Unpooled.wrappedBuffer(JSON.toJSONBytes(msg.getMessage()))) .build()); &#125; return Mono.empty(); &#125;); &#125; 打成jar包上传到平台","categories":[{"name":"物联网","slug":"物联网","permalink":"http://liujun1997.github.io/categories/%E7%89%A9%E8%81%94%E7%BD%91/"}],"tags":[{"name":"IOT chieflinks","slug":"IOT-chieflinks","permalink":"http://liujun1997.github.io/tags/IOT-chieflinks/"}]},{"title":"cdh安装部署","slug":"cdh安装部署","date":"2021-08-06T15:27:54.000Z","updated":"2021-09-05T05:45:14.000Z","comments":true,"path":"2021/08/06/cdh安装部署/","link":"","permalink":"http://liujun1997.github.io/2021/08/06/cdh%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/","excerpt":"","text":"CDH6.3.2 安装[toc] 1.安装说明1.安全前置准备，包括安装操作系统、关闭防火墙、同步服务器时钟等 2.外部数据库如MySQL安装 3.安装Cloudera Manager 4.安装CDH集群 请务必注意CDH6的安装前置条件包括如下： 外部数据库支持： MySQL 5.7或更高 MariaDB 5.5或更高 PostgreSQL 8.4或更高 Oracle 12c或更高 java环境： Oracle JDK1.8，将不再支持JDK1.7 操作系统支持 RHEL 6.8或更高 RHEL 7.2或更高 SLES 12 SP2或更高 Ubuntu 16或更高 2.集成环境2.1操作脚本 创建shell目录 mkdir -p /opt/shell/ 创建node.list文件 1touch node.list 添加如下内容： 123456master01.health.bigdata.commaster02.health.bigdata.comslave01.health.bigdata.comslave02.health.bigdata.comslave03.health.bigdata.comslave04.health.bigdata.com 创建ssh_no_passwd.sh文件 1touch ssh_no_passwd.sh 添加内容如下： 12345678910111213141516171819202122232425#!/bin/baships_name=$1#获取当前目录的绝对路径path_dir=`pwd`#找到ips文件的位置,并查看里面的内容 赋给ips_arrremote_hosts=`cat $&#123;path_dir&#125;/$&#123;ips_name&#125;`if [ -f &quot;/root/.ssh/id_rsa.pub&quot; ]|| [ -f &quot;/root/.ssh/id_rsa&quot;];then echo &quot;文件已经存在&quot;else echo &quot;文件不存在准备创建&quot; echo &quot;准备创建公钥文件&quot; ssh-keygen -t rsa -q -f &quot;/root/.ssh/id_rsa&quot; -P &#x27;&#x27;fiecho &quot;公钥创建完成&quot;echo &quot;传送至远端主机&quot;echo &quot;一共有$#台主机需要配置&quot;if [ ! -z $# ];then for host in $remote_hosts do ssh-copy-id -i /root/.ssh/id_rsa.pub $host doneelse echo &quot;请至少输入一台服务器地址&quot;fi 创建ssh_do_all.sh文件 1touch ssh_do_all.sh 添加内容如下： 1234567891011121314151617181920212223242526272829#! /bin/bash#拿到外面传进来的命令ips_name=$1cmd=&quot;&quot;for((i=2;i&lt;=$#;i++)); do j=$&#123;!i&#125; cmd=&quot;$&#123;cmd&#125; $j &quot;doneecho &quot;&#x27;$&#123;cmd&#125;&#x27;&quot;#进入到当前脚本所在的路径cd `dirname $0`#获取当前目录的绝对路径path_dir=`pwd`#找到ips文件的位置,并查看里面的内容 赋给ips_arrips_arr=`cat $&#123;path_dir&#125;/$&#123;ips_name&#125;`for ip in $&#123;ips_arr[*]&#125;do #拼接ssh命令:ssh用户名@主机名 命令 cmd_=&quot;ssh $ip &#x27;$cmd&#x27;&quot; echo $cmd_ #通过eval 实现动态执行命令 if eval $cmd_; then echo &#x27;ok&#x27; else echo &#x27;fail&#x27; fidone 执行命令: 1sh ssh_do_all.sh node.list df -h 创建scp_do_all.sh文件 1touch scp_do_all.sh 添加内容如下: 1#! /bin/bash#脚本使用说明# ./scp_do_all.sh f1 /home/luser/dirips_name=$1#你要传的文件source_=$2#目标目录target=$3#先进入当前脚本的所在路径cd `dirname $0`#获取当前目录的绝对路径path_dir=`pwd`#找到ips文件的位置，并查看里面的内容 赋给 ips_arrips_arr=(`cat $&#123;path_dir&#125;/$&#123;ips_name&#125;`)for ip in $&#123;ips_arr[*]&#125;do #拼接scp 命令： scp 你要传的文件 用户名@主机名:目标目录 cmd_=&quot;scp $source_ $ip:$target&quot; echo $cmd_ #通过eval 实现动态执行命令 if eval $cmd_ ; then echo &#x27;ok&#x27; else echo &#x27;fail&#x27; fidone 执行命令: 1sh scp_do_all.sh node.list /etc/hosts /etc/ 2.2hostname修改各节点的hostname配置 1vi /etc/hostname#hostnameip-172-31-13-38.ap-southeast-1.compute.internal 或者你可以通过命令修改立即生效 hostnamectl set-hostname ip-172-31-13-38.ap-southeast-1.compute.internal 2.3hosts配置1vi /etc/hosts 1[root@gxwj-zhongjj-8 ~]# cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain619.50.65.66 master01.health.bigdata.com19.50.65.67 master02.health.bigdata.com19.50.65.68 slave01.health.bigdata.com19.50.65.71 slave02.health.bigdata.com19.50.65.75 slave03.health.bigdata.com19.50.65.76 slave04.health.bigdata.com 将文件复制的集群的各个节点 2.4SSH免登陆 在主节点执行sh脚本 执行命令 1ssh ssh_no_passwd.sh node.list 2.5配置iso镜像源创建iso目录 1mkdir /opt/iso 创建http目录 1sudo mkdir /var/www/html/iso 将ISO镜像文件移到/opt/iso目录 1cp CentOS-7-x86_64-DVD-1908.iso /opt/iso 临时挂载，重启无效 1sudo mount -o loop /opt/iso/CentOS-7-x86_64-DVD-1908.iso /var/www/html/iso 通过 df -h命令查看 永久挂载操作系统iso文件 注意格式，容易出错，内容tab键隔开 1vi /etc/fstab 最末端添加内容 1/opt/iso/CentOS-7-x86_64-DVD-1908.iso /var/www/html/iso/ iso9660 defaults,ro,loop 0 0 执行重新加载命令 1mount -a 内容格式不对，会出错，如下： 显示/etc/fstab的内容 1mount 查看是否挂载成功 注意：如果不成功，需要修改配置内容与格式，否则系统重启无法进入用户会话 1df -h 配置操作系统repo 创建os.repo文件 1sudo vim /etc/yum.repos.d/os.repo 本地os.repo配置内容 1[local_iso]name=CentOS-$releasever - Mediabaseurl=file:///var///www///html///isogpgcheck=0enabled=1 同时按照httpd服务 yum install httpd 其他服务器节点os.repo配置内容 1[osrepo]#自定义名称name=os_repo#yum访问路径baseurl=http://19.50.65.66/iso/#启用yum源，0为不启用，1为启用enabled=1#检查GPG-KEY，0为不检查，1为检查gpgcheck=0 删除所有默认的repo所有节点都是 1/etc/yum.repo.d/ 查看当前可用的源 1sudo yum repolist 清除缓存 1yum clean all 2.6集群时钟同步参考网上ntp安装教程 批量添加定时同步时间 1vi ntpCrontab.sh 内容如下： 1#!/bin/baships_name=$1#获取当前目录的绝对路径path_dir=`pwd`#找到ips文件的位置,并查看里面的内容 赋给ips_arrremote_hosts=`cat $&#123;path_dir&#125;/$&#123;ips_name&#125;`for i in cat $remote_hostsdo echo $i ssh $i &quot;(echo &#x27;0 */10 * * * /usr/sbin/ntpdate -u 19.50.65.66&#x27; ;crontab -l) |crontab&quot; echo &quot;Synchronization is complete.&quot;done 或者(推荐) ntpdate.sh 1#!/usr/bin/env bashcd /opt/shellsh ssh_do_all.sh ipa.list ntpdate -u cdhclient sudo vi /etc/crontab 1SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed#添加内容*/5 * * * * root /opt/shell/ntpdate.sh &gt;&gt; /opt/shell/ntpdate.log 重启cron定时服务 1systemctl status crond 1systemctl restart crond 2.7ansible安装安装依赖 1yum install -y ansible 配置/etc/ansible/hosts 1##补充内容# This is the default ansible &#x27;hosts&#x27; file.## It should live in /etc/ansible/hosts## - Comments begin with the &#x27;#&#x27; character# - Blank lines are ignored# - Groups of hosts are delimited by [header] elements# - You can enter hostnames or ip addresses# - A hostname/ip can be a member of multiple groups# Ex 1: Ungrouped hosts, specify before any group headers.## green.example.com## blue.example.com## 192.168.100.1## 192.168.100.10# Ex 2: A collection of hosts belonging to the &#x27;webservers&#x27; group## [webservers]## alpha.example.org## beta.example.org## 192.168.1.100## 192.168.1.110# If you have multiple hosts following a pattern you can specify# them like this:## www[001:006].example.com# Ex 3: A collection of database servers in the &#x27;dbservers&#x27; group## [dbservers]#### db01.intranet.mydomain.net## db02.intranet.mydomain.net## 10.25.1.56## 10.25.1.57# Here&#x27;s another example of host ranges, this time there are no# leading 0s:## db-[99:101]-node.example.com[all]cdhmaster1.chiefdata.netcdhnode1.chiefdata.netcdhnode2.chiefdata.netcdhnode3.chiefdata.netcdhnode4.chiefdata.netcdhclient.chiefdata.net[ntp]cdhmaster1.chiefdata.netcdhnode1.chiefdata.netcdhnode2.chiefdata.netcdhnode3.chiefdata.netcdhnode4.chiefdata.net[ipa]cdhmaster1.chiefdata.netcdhnode1.chiefdata.netcdhnode2.chiefdata.netcdhnode3.chiefdata.netcdhnode4.chiefdata.net 执行批量操作命令 批量执行命令： 1ansible all -m command -a &quot;df -h&quot; all 是分组命令 批量执行shell文件： 1ansible all -m script -a ./check_env.sh 2.7初始化配置创建check_env.sh文件 1touch check_env.sh 增加文件内容： 1vi check_env.sh 内容如下： 1#!/bin/bash# 系统时间datetime=`date &quot;+%Y%m%d%H%M%S&quot;`# 关闭 firewalldsystemctl stop firewalldsystemctl disable firewalld#关闭 selinuxcp /etc/selinux/config /tmp/selinux_config.&quot;$datetime&quot;setenforce 0SELINUX=`grep &#x27;SELINUX=&#x27; /etc/selinux/config|grep -v &quot;^#&quot;|awk -F&quot;=&quot; &#x27;&#123;print $2&#125;&#x27;`if [ &quot;$SELINUX&quot; == &quot;enforcing&quot; ];then sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/configelif [ &quot;$SELINUX&quot; == &quot;permissive&quot; ];then sed -i &#x27;s/SELINUX=permissive/SELINUX=disabled/g&#x27; /etc/selinux/configelse echo &quot;have already been disabled,Don&#x27;t need to modify&quot;fi# 关闭 tunedtuned-adm offtuned=`systemctl status tuned|grep &#x27;Active: active (running)&#x27;|wc -l`if [ $tuned == 1 ];then systemctl stop tuned echo &#x27;tuned stop successful&#x27;else echo &#x27;tuned already stopped&#x27;fisystemctl disable tuned# 设置 vm.swappinesscp /etc/sysctl.conf /tmp/etc_sysctl.&quot;$datetime&quot;sysctl -w vm.swappiness=1swappiness=`grep &quot;vm.swappiness=&quot; /etc/sysctl.conf|awk -F &quot;=&quot; &#x27;&#123;print $2&#125;&#x27;`if [ &quot;$swappiness&quot; -gt 1 ];then sed -i &#x27;s/vm.swappiness=&#x27;$swappiness&#x27;/vm.swappiness=1/g&#x27; /etc/sysctl.confelif [ ! -n &quot;$swappiness&quot; ];then echo &quot;vm.swappiness=1&quot; &gt;&gt; /etc/sysctl.confelse echo &quot;swappiness=1,Don&#x27;t need to modify&quot;fi# 设置 THPcp /sys/kernel/mm/transparent_hugepage/enabled /tmp/THP_enabled.&quot;$datetime&quot;cp /sys/kernel/mm/transparent_hugepage/defrag /tmp/THP_defrag.&quot;$datetime&quot;cp /etc/rc.d/rc.local /tmp/rc.local.&quot;$datetime&quot;echo &quot;never&quot; &gt; /sys/kernel/mm/transparent_hugepage/enabledecho &quot;never&quot; &gt; /sys/kernel/mm/transparent_hugepage/defragthp_enabled=`grep &quot;transparent_hugepage&quot; /etc/rc.d/rc.local|grep &quot;enabled&quot;`thp_defrag=`grep &quot;transparent_hugepage&quot; /etc/rc.d/rc.local|grep &quot;defrag&quot;`if [ ! -n &quot;$thp_enabled&quot; ];then echo &#x27;echo &quot;never&quot; &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; &gt;&gt; /etc/rc.d/rc.localfiif [ ! -n &quot;$thp_defrag&quot; ];then echo &#x27;echo &quot;never&quot; &gt; /sys/kernel/mm/transparent_hugepage/defrag&#x27; &gt;&gt; /etc/rc.d/rc.localfichmod +x /etc/rc.d/rc.local 执行批量操作命令 批量执行shell文件： 注意：all 是分组，对应配置/etc/ansible/hosts配置里面的[all]内容 1ansible all -m script -a ./check_env.sh 2.8安装mariadb数据库1.安装MariaDB 1[root@ip-172-31-13-38 ~]# yum -y install mariadb[root@ip-172-31-13-38 ~]# pyyum -y install mariadb-server 2.启动并配置MariaDB 1[root@ip-172-31-13-38 ~]# systemctl start mariadb[root@ip-172-31-13-38 ~]# systemctl enable mariadbCreated symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.[root@ip-172-31-13-38 ~]# /usr/bin/mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&#x27;ll need the currentpassword for the root user. If you&#x27;ve just installed MariaDB, andyou haven&#x27;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): 输入密码OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] YNew password:Re-enter new password:Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] Y ... Success!Normally, root should only be allowed to connect from &#x27;localhost&#x27;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] n ... skipping.By default, MariaDB comes with a database named &#x27;test&#x27; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] Y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] Y ... Success!Cleaning up...All done! If you&#x27;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB! 3.权限配置 1mysql -u root -h localhost -p 1GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;12345678&#x27; 这里的123456为你给新增权限用户设置的密码，%代表所有主机，也可以具体到你的主机ip地址 1;flush privileges; 2.9建立组件服务需要的数据表登录mysql 或者直接通过navicat 工具远程操作也可以，方便些 1mysql -u root -h localhost -p 执行脚本 1CREATE DATABASE IF NOT EXISTS hbd_manage DEFAULT CHARSET utf8 COLLATE utf8_general_ci;CREATE DATABASE IF NOT EXISTS dolphinscheduler DEFAULT CHARSET utf8 COLLATE utf8_general_ci;create database metastore default character set utf8;CREATE USER &#x27;ds&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;GRANT ALL PRIVILEGES ON dolphinscheduler . * TO &#x27;ds&#x27;@&#x27;%&#x27;;FLUSH PRIVILEGES;create database health_metastore default character set utf8;create database health_cm default character set utf8;create database health_hue default character set utf8;create database health_sentry default character set utf8;create database health_oozie default character set utf8;create database health_am default character set utf8;create database health_rm default character set utf8;create database health_nav_ms default character set utf8;create database health_nav_as default character set utf8; 2.10安装JDBC驱动上传mysql-connector-java-5.1.34.jar到服务器 创建软连接 所有节点都需要做统一操作 1mkdir -p /usr/share/java/cp mysql-connector-java-5.1.34.jar /usr/share/java/chmod 777 /usr/share/java/mysql-connector-java-5.1.34.jarln -s /usr/share/java/mysql-connector-java-5.1.34.jar /usr/share/java/mysql-connector-java.jar 或者直接改名 mysql-connector-java.jar 3.CM安装3.1配置cm repo源把cm6.3.1和cdh6.3.2文件夹拷贝到httpd服务器上 注意：这里的服务器是FreeIPA的服务端，因为FreeIPA的服务端已经安装了httpd 上传至：**/var/www/html** 目录 创建repo 安装create repo 1yum install createrepo 在cm6.3.1文件夹里面执行，cdh6.3.2不需要此操作 1createrepo . 制作cm的repo源 创建cm.repo文件 1sudo vim /etc/yum.repos.d/cm.repo cm.repo配置内容 1[cm_repo]name = cm_repobaseurl = http://19.50.65.66/cm6.3.1enabled = 1gpgcheck = 0 把cm.repo 上传到其他节点服务器 1sh scp_do_all.sh node.list /etc/yum.repos.d/cm.repo /etc/yum.repos.d/ 查看当前可用的源 1sudo yum repolist 清除缓存 1yum clean all 3.2安装JDK批量安装命令，安装cm自带的jdk 1sh ssh_do_all.sh node.list yum -y install oracle-j2sdk1.8-1.8.0+update181-1.x86_64 Jdk环境变量配置 执行命令 1vim /etc/profile 配置内容 1export JAVA_HOME=/usr/java/jdk1.8.0_181-clouderaexport CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 复制到其他服务节点 1sh scp_do_all.sh node.list /etc/profile /etc/ 重新加载 1source /etc/profilesh ssh_do_all.sh node.list source /etc/profile 卸载旧版jdk 确定JDK的版本 1rpm -qa | grep jdkrpm -qa | grep gcj 查看的结果是： 1libgcj-4.1.2-42.el5 java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 java-1.8.0-openjdk-headless-1.8.0.242.b08-0.el7_7.x86_64 2.然后卸载： 1yum -y remove java-1.8.0-openjdk-headless-1.8.0.242.b08-0.el7_7.x86_64 1sh ssh_do_all.sh node.list yum -y remove java-1.8.0-openjdk-headless-1.8.0.242.b08-0.el7_7.x86_64 如果这种方法不行，可以使用如下的方法卸载： 11）卸载系统自带的jdk版本： 查看自带的jdk： #rpm -qa|grep gcj 可能看到如下类似的信息： libgcj-4.1.2-44.el5 java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 使用rpm -e --nodeps 命令删除上面查找的内容： #rpm -e –nodeps java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 2）卸载rpm安装的jkd版本 查看安装的jdk： #rpm -qa|grep jdk 可能看到如下类似的信息： jdk-1.6.0_22-fcs 卸载： #rpm -e --nodeps jdk-1.6.0_22-fcs 3）找到jdk安装目录的_uninst子目录·在shell终端执行命令./uninstall.sh即可卸载jdk 3.2安装Cloudera Manager3.3.1Cloudera Manager Server安装通过yum安装Cloudera Manager Server 1yum -y install cloudera-manager-server 初始化数据库 1/opt/cloudera/cm/schema/scm_prepare_database.sh -h192.168.18.188 --scm-host 192.168.18.188 mysql cdh_cm root 12345678 启动CM server 1systemctl start cloudera-scm-serversystemctl status cloudera-scm-serversystemctl stop cloudera-scm-server#开机启动systemctl enable cloudera-scm-server 3.3.2Cloudera Manager Agent安装注意：此步骤可以忽略，让cm管理平台自动安装，所有节点都要安装 通过yum安装Cloudera Manager Agent 1yum -y install cloudera-manager-agent 启动CM agent 1systemctl start cloudera-scm-agentsystemctl status cloudera-scm-agentsystemctl stop cloudera-scm-agent#开机启动systemctl enable cloudera-scm-agent 3.4CDH安装3.4.1CDH集群安装向导 admin/admin登录到CM 同意license协议，点击继续 选择60试用，点击继续 或者直接选择免费开源版 点击“继续”systemctl restart cloudera-scm-agent 点击“继续”，输入集群名称，可以使用默认的“Cluster 1”。 输入主机IP或者名称，点击搜索找到主机后点击继续 选择自定义存储库，输入cm的http地址 ​ “CDH and other software”中选择“使用 Parcel (建议)”，点击“ 更多选项”，点击“-”删除其它所有地址，输入http://172.31.13.38/cdh6.3，点击“保存更改” 点击“继续”，进入下一步安装jdk 点击“继续”，进入下一步配置ssh账号密码 相同密码： 公钥： 把主节点的私钥上传到上面 点击“继续”，进入下一步，安装Cloudera Manager相关到各个节点 等待Agent安装完毕后，自动跳转到下一步开始分发Parcel 点击“继续”，进入下一步安装cdh到各个节点 点击Inspect Network Performance和Inspect Hosts，检查主机 如果有错误或者黄色警告，查看“显示检查器结果”，并逐项解决，然后“重新运行”检查，直到所有的检查都通过，否则没办法点击继续下一步。 3.4.2集群设置安装向导 选择需要安装的服务，根据需要选择，这里随便选择Data Warehouse，也可以自定义服务 点击“继续”，进入集群角色分配，一台机器作为管理节点，另外三台机器作为DataNode 注意：Activity Monitor和Telemetry Publisher不用选择任何主机，留空，即不安装，因为用不到。 点击“继续”，进入下一步，测试数据库连接 测试成功，点击“继续”，进入目录设置，此处使用默认默认目录，根据实际情况进行目录修改 点击“继续”，进入各个服务启动 安装成功后进入home管理界面 3.4.3组件版本检查 可以看到Hadoop3.0，Flume1.9，HBase2.1，Hive2.1.1，Spark2.4，Hue4.2.0，Impala3.2，Kafka2.2.1，Kudu1.0，Oozie5.1，Pig0.17，Senty2.1，Solr7.4，Sqoop1.4.7，Zookeeper3.4.5等。","categories":[{"name":"大数据","slug":"大数据","permalink":"http://liujun1997.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://liujun1997.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"http://liujun1997.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"软件安装","slug":"软件安装","permalink":"http://liujun1997.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"运维","slug":"运维","permalink":"http://liujun1997.github.io/categories/%E8%BF%90%E7%BB%B4/"},{"name":"树莓派","slug":"树莓派","permalink":"http://liujun1997.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"Linux","slug":"Linux","permalink":"http://liujun1997.github.io/categories/Linux/"},{"name":"物联网","slug":"物联网","permalink":"http://liujun1997.github.io/categories/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"大数据","slug":"大数据","permalink":"http://liujun1997.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://liujun1997.github.io/tags/mysql/"},{"name":"Mysql Linux","slug":"Mysql-Linux","permalink":"http://liujun1997.github.io/tags/Mysql-Linux/"},{"name":"Linux 磁盘分区","slug":"Linux-磁盘分区","permalink":"http://liujun1997.github.io/tags/Linux-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"},{"name":"Linux Shell","slug":"Linux-Shell","permalink":"http://liujun1997.github.io/tags/Linux-Shell/"},{"name":"树莓派 网络","slug":"树莓派-网络","permalink":"http://liujun1997.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE-%E7%BD%91%E7%BB%9C/"},{"name":"Linux","slug":"Linux","permalink":"http://liujun1997.github.io/tags/Linux/"},{"name":"Java","slug":"Java","permalink":"http://liujun1997.github.io/tags/Java/"},{"name":"IOT chieflinks","slug":"IOT-chieflinks","permalink":"http://liujun1997.github.io/tags/IOT-chieflinks/"},{"name":"大数据","slug":"大数据","permalink":"http://liujun1997.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]}
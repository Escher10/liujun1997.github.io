{"meta":{"title":"Escher","subtitle":"","description":"This is Escher's Blog","author":"Escher","url":"http://liujun1997.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-08-06T14:45:53.168Z","updated":"2021-08-06T14:45:53.168Z","comments":false,"path":"/404.html","permalink":"http://liujun1997.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-08-07T05:40:25.095Z","updated":"2021-08-07T05:40:25.078Z","comments":false,"path":"about/index.html","permalink":"http://liujun1997.github.io/about/index.html","excerpt":"","text":"二线城市苦逼搬砖码农"},{"title":"分类","date":"2021-08-06T14:46:02.462Z","updated":"2021-08-06T14:46:02.462Z","comments":false,"path":"categories/index.html","permalink":"http://liujun1997.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-08-06T14:46:44.738Z","updated":"2021-08-06T14:46:44.738Z","comments":false,"path":"books/index.html","permalink":"http://liujun1997.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-08-06T14:46:15.343Z","updated":"2021-08-06T14:46:15.343Z","comments":true,"path":"links/index.html","permalink":"http://liujun1997.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-08-06T14:46:08.835Z","updated":"2021-08-06T14:46:08.834Z","comments":false,"path":"repository/index.html","permalink":"http://liujun1997.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-06T14:46:51.571Z","updated":"2021-08-06T14:46:51.571Z","comments":false,"path":"tags/index.html","permalink":"http://liujun1997.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Cron表达式解析","slug":"Cron表达式解析","date":"2021-08-10T07:30:42.000Z","updated":"2021-08-10T07:47:36.523Z","comments":true,"path":"2021/08/10/Cron表达式解析/","link":"","permalink":"http://liujun1997.github.io/2021/08/10/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Corn表达式解析1.概念 cron是表示定时任务执行规律的一串字符串，通常由5/6个字符隔开，用6，7个域表示。每个域由以下几种字符组成 *****表示任意值都满足条件。 **,**表示选定的几个值满足条件。秒域1,5，表示 在1秒和5秒之间触发 **-**表示范围，秒域1,5表示 ，在1秒与5秒之间触发每一秒到触发 / 表示在某个时间起，每隔固定的时间执行一次，秒域0/5表示从0秒开始，每隔5秒触发，5，10，15秒都会触发。秒域*/5表示从执行开始，每隔5s触发一次。比如执行的时候是第3s，则8，13秒都会触发。 ？表示在两个可能的矛盾字段中，忽略其中一个字段的值。通常是用在 dayofweek和dayofmouth这两个字段中，只能用一次。 **L **表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 W 表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。 LW 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 # 表示每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。 2.字段含义 字段 允许值 允许的特殊字符 秒（Seconds） 0~59的整数 , - * / 四个字符 分（Minutes） 0~59的整数 , - * / 四个字符 小时（Hours） 0~23的整数 , - * / 四个字符 日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? / L W C 八个字符 月份（Month） 1~12的整数或者 JAN-DEC , - * / 四个字符 星期（DayofWeek） 1~7的整数或者 SUN-SAT （1=SUN） , - * ? / L C # 八个字符 3.常见的域12345678910111213141516171819202122232425262728293031323334353637383940414243（1）0 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务 （2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业 （3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 （4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 （5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 （6）0 0 12 ? * WED 表示每个星期三中午12点 （7）0 0 12 * * ? 每天中午12点触发 （8）0 15 10 ? * * 每天上午10:15触发 （9）0 15 10 * * ? 每天上午10:15触发 （10）0 15 10 * * ? * 每天上午10:15触发 （11）0 15 10 * * ? 2005 2005年的每天上午10:15触发 （12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 （13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 （14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 （15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 （16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 （17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 （18）0 15 10 15 * ? 每月15日上午10:15触发 （19）0 15 10 L * ? 每月最后一日的上午10:15触发 （20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 （21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 （22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发","categories":[{"name":"Linux","slug":"Linux","permalink":"http://liujun1997.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://liujun1997.github.io/tags/Linux/"},{"name":"Java","slug":"Java","permalink":"http://liujun1997.github.io/tags/Java/"}]},{"title":"物联网","slug":"物联网","date":"2021-08-07T06:44:17.000Z","updated":"2021-08-07T06:44:45.509Z","comments":true,"path":"2021/08/07/物联网/","link":"","permalink":"http://liujun1997.github.io/2021/08/07/%E7%89%A9%E8%81%94%E7%BD%91/","excerpt":"","text":"一. 接入流程![image-20201222171458788](/Users/mac/Library/Application Support/typora-user-images/image-20201222171458788.png) 二.系统开发说明1.1 名词解析 产品: 对某一型设备的分类,通常是已经存在的某一个设备型号. 设备：具体的某一个设备. 网络组件: 用于管理各种网络服务(MQTT,TCP等),动态配置,启停. 只负责接收,发送报文,不负责任何处理逻辑。 协议: 用于自定义消息解析规则,用于认证、将设备发送给平台报文解析为平台统一的报文，以及处理平台下发给设备的指令。 设备网关: 负责平台侧统一的设备接入,使用网络组件处理对应的请求以及报文,使用配置的协议解析为平台统一的设备消息。 1.3 平台统一设备消息定义 平台使用自定义的协议包将设备上报的报文解析为平台统一的消息,来进行统一管理。 平台统一消息基本于物模型中的定义相同,主要由属性(property),功能(function),事件(event)组成. 1.2 消息组成 消息主要由deviceId,messageId,headers,timestamp组成. 1.3 属性相关消息 获取设备属性(ReadPropertyMessage)对应设备回复的消息ReadPropertyMessageReply. 设备上报属性(ReportPropertyMessage) 由设备上报. 1234567891011121314151617181920212223ReadPropertyMessage&#123; Map&lt;String,Object&gt; headers; String deviceId; String messageId; long timestamp; //时间戳(毫秒) List&lt;String&gt; properties;//可读取多个属性&#125;ReadPropertyMessageReply&#123; Map&lt;String,Object&gt; headers; String deviceId; String messageId; long timestamp; //时间戳(毫秒) boolean success; Map&lt;String,Object&gt; properties;//属性键值对&#125;ReportPropertyMessage&#123; Map&lt;String,Object&gt; headers; String deviceId; String messageId; long timestamp; //时间戳(毫秒) Map&lt;String,Object&gt; properties;&#125; 1.4 功能相关消息 调用设备功能到消息(FunctionInvokeMessage)由平台发往设备,对应到返回消息FunctionInvokeMessageReply 事件消息EventMessage由设备端发往平台. 12345678910111213141516171819202122FunctionInvokeMessage&#123; Map&lt;String,Object&gt; headers; String functionId;//功能标识,在元数据中定义. String deviceId; String messageId; long timestamp; //时间戳(毫秒) List&lt;FunctionParameter&gt; inputs;//输入参数&#125;FunctionParameter&#123; String name; Object value;&#125;FunctionInvokeMessageReply&#123; Map&lt;String,Object&gt; headers; String deviceId; String messageId; long timestamp; boolean success; Object output; //输出值,需要与元数据定义中的类型一致&#125; 1.5 事件相关消息 事件消息EventMessage由设备端发往平台. 123456EventMessage&#123; Map&lt;String,Object&gt; headers; String event; //事件标识,在元数据中定义 Object data; //与元数据中定义的类型一致,如果是对象类型,请转为java.util.HashMap,禁止使用自定义类型. long timestamp; //时间戳(毫秒)&#125; 1.6 其他相关消息 DeviceOnlineMessage 设备上线消息,通常用于网关代理的子设备的上线操作. DeviceOfflineMessage 设备上线消息,通常用于网关代理的子设备的下线操作. 123456EventMessage&#123; Map&lt;String,Object&gt; headers; String event; //事件标识,在元数据中定义 Object data; //与元数据中定义的类型一致,如果是对象类型,请转为java.util.HashMap,禁止使用自定义类型. long timestamp; //时间戳(毫秒)&#125; 二. 设备接入2.1 产品物模型定义 属性用于定义一些指标数据,如:电压,温度等. 属性都应该是简单的数据类型, 功能用于定义设备具有的一些可执行动作,如: 消音,关灯,云台控制.根据情况设计好输入参数和输出参数. 事件用于定义设备在特定条件时,发生的动作,如:火警,\b检测到人脸,通常为结构体类型,用于保存比较复杂的数据. 标签对于设备固有不变的信息,建议使用设备标签进行管理,如设备地理位置等. ![image-20201222173831786](/Users/mac/Library/Application Support/typora-user-images/image-20201222173831786.png) 2.2 协议包开发 协议是设备与平台通信的一种标准，某个设备想与平台进行通信就必须按照某种协议标准进行规定上报的数据格式，支持jar包形式 平台封装了网络通信,但是具体的数据由消息协议进行解析.协议(ProtocolSupport)主要由认证器(Authenticator), 消息编解码器(DeviceMessageCodec),消息发送拦截器(DeviceMessageSenderInterceptor)以及配置元数据(ConfigMetadata)组成 认证器(Authenticator)是用于在收到设备请求(例如MQTT)时,对客户端进行认证时使用,不同的网络协议(Transport)使用不同的认证器. 1234567891011121314151617181920212223public interface Authenticator &#123; /** * 对指定对设备进行认证 * * @param request 认证请求 * @param device 设备 * @return 认证结果 */ Mono&lt;AuthenticationResponse&gt; authenticate(@Nonnull AuthenticationRequest request, @Nonnull DeviceOperator device); /** * 在MQTT服务网关中指定了认证协议时,将调用此方法进行认证。 * 注意: 认证通过后,需要设置设备ID.&#123;@link AuthenticationResponse#success(String)&#125; * @param request 认证请求 * @param registry 设备注册中心 * @return 认证结果 */ default Mono&lt;AuthenticationResponse&gt; authenticate(@Nonnull AuthenticationRequest request, @Nonnull DeviceRegistry registry) &#123; return Mono.just(AuthenticationResponse.success()); &#125;&#125; 用于将平台统一的消息(Message)与设备端能处理的消息(EncodedMessage)进行相互转换. 设备网关从网络组件中接收到报文后,会调用对应协议包的消息编解码器进行处理. 不同网络协议需要转换为不同的EncodedMessage类型.比如,MQTT需要转换为MqttMessage. 12345678class DeviceMessageCodec&#123; //此编解码器支持的网络协议,如: DefaultTransport.MQTT Transport getSupportTransport(); //将平台发往设备的消息编码为设备端对消息 Publisher&lt;? extends EncodedMessage&gt; encode(MessageEncodeContext context); //将设备发往平台的消息解码为平台统一的消息 Publisher&lt;? extends Message&gt; decode(MessageDecodeContext context);&#125; EncodedMessage从网络组件中接收到的消息,不同的网络组件消息类型不同 1234567891011121314151617class EncodedMessage&#123; //获取原始报文 ByteBuf getPayload(); //报文转为字符串 String payloadAsString(); //报文转为JSON对象 JSONObject payloadAsJson(); //报文转为JSON数组 JSONArray payloadAsJsonArray(); // 报文转为字节数组 byte[] payloadAsBytes()&#125;//mqtt消息class MqttMessage extends EncodedMessage&#123; String getTopic(); int getQos();&#125; ConfigMetadata 配置元数据用于告诉平台,在使用此协议的时候,需要添加一些自定义配置到设备配置，(DeviceOperator.setConfig)中. 在其他地方可以通过DeviceOperator.getConfig获取这些配置. 123456789101112131415CompositeProtocolSupport support = new CompositeProtocolSupport();support.setId(&quot;demo-v1&quot;);support.setName(&quot;演示协议v1&quot;);support.setDescription(&quot;演示协议&quot;);support.setMetadataCodec(new ChiefLinksDeviceMetadataCodec()); //固定为JetLinksDeviceMetadataCodec,请勿修改.DefaultConfigMetadata mqttConfig = new DefaultConfigMetadata( &quot;MQTT认证配置&quot; , &quot;&quot;) .add(&quot;username&quot;, &quot;username&quot;, &quot;MQTT用户名&quot;, new StringType()) .add(&quot;password&quot;, &quot;password&quot;, &quot;MQTT密码&quot;, new PasswordType()) .add(&quot;productKey&quot;, &quot;productKey&quot;, &quot;产品密钥&quot;, new PasswordType(),DeviceConfigScope.product) //只有产品需要配置 ;//设置MQTT所需要到配置 support.addConfigMetadata(DefaultTransport.MQTT, mqttConfig); DeviceMessageSenderInterceptor 使用拦截器可以拦截消息发送和返回的动作 1234567DeviceMessageSenderInterceptor&#123; //发送前 Mono&lt;DeviceMessage&gt; preSend(DeviceOperator device, DeviceMessage message); //发送后 &lt;R extends DeviceMessage&gt; Flux&lt;R&gt; afterSent(DeviceOperator device, DeviceMessage message, Flux&lt;R&gt; reply);&#125; 2.3 创建对应的网关或者网络组件 选择 网络组件–&gt;组件管理–&gt; 点击新增组件按钮，新建对应的网络组件，在创建完成的模块上点击启动按钮 ![image-20201222173951304](/Users/mac/Library/Application Support/typora-user-images/image-20201222173951304.png) 选择 网络组件–&gt;设备网关–&gt; 点击新建按钮。在操作列点击启动按钮启动网关。 ![image-20201222174023253](/Users/mac/Library/Application Support/typora-user-images/image-20201222174023253.png) 2.4 创建设备实例 选择 设备管理–&gt;设备–&gt; 点击添加设备按钮，填写对应的信息添加 ![image-20201222173901028](/Users/mac/Library/Application Support/typora-user-images/image-20201222173901028.png) 2.5 设备调试 使用mqtfx工具模拟设备调试 三. 接入协议开发说明 平台支持mqtt协议，http协议，tcp协议，推荐使用mqtt协议，broker模式接入，平台提供一个此对接模式样例。 3.1 开发步骤 新建org.chieflinks.demo.protocol，创建协议编码解码类：DemoDeviceMessageCodec 123456789101112131415161718@AllArgsConstructor@Slf4jpublic class DemoDeviceMessageCodec implements DeviceMessageCodec &#123; @Override public Transport getSupportTransport() &#123; return DefaultTransport.Mqtt; &#125; @Override public Mono&lt;? extends Message&gt; decode(MessageDecodeContext context) &#123; return Mono.empty(); &#125; @Override public Publisher&lt;? extends EncodedMessage&gt; encode(MessageEncodeContext context) &#123; retrun Mono.empty(); &#125;&#125; 创建协议入口类： DemoProtocolSupportProvider 1234567891011121314public class DemoProtocolSupportProvider implements ProtocolSupportProvider &#123; @Override public Mono&lt;? extends ProtocolSupport&gt; create(ServiceContext context) &#123; CompositeProtocolSupport support = new CompositeProtocolSupport(); support.setId(&quot;xx&quot;); support.setName(&quot;xxx&quot;); support.setDescription(&quot;xxx&quot;); support.setMetadataCodec(new ChiefLinksDeviceMetadataCodec()); DemoDeviceMessageCodec codec = new DemoDeviceMessageCodec(); support.addMessageCodecSupport(DefaultTransport.Mqtt, () -&gt; Mono.just(codec)); return Mono.just(support); &#125; &#125; 消息上报解码 123456789101112@Overridepublic Mono&lt;? extends Message&gt; decode(MessageDecodeContext context) &#123; return Mono.fromSupplier(() -&gt; &#123; MqttMessage mqttMessage = (MqttMessage) context.getMessage(); String topic = mqttMessage.getTopic(); JSONObject payload = JSON.parseObject(mqttMessage.getPayload().toString(StandardCharsets.UTF_8)); String deviceId = context.getDevice() != null ? context.getDevice().getDeviceId() : null; return doDecode(deviceId, topic, payload); &#125;); &#125; 平台发送消息给设备(编码) 123456789101112131415161718192021222324public Mono&lt;EncodedMessage&gt; encode(MessageEncodeContext context) &#123; Message message = context.getMessage(); return Mono.defer(() -&gt; &#123; if (message instanceof DeviceMessage) &#123; if (message instanceof DisconnectDeviceMessage) &#123; return ((ToDeviceMessageContext) context) .disconnect() .then(Mono.empty()); &#125; TopicMessage msg = doEncode((DeviceMessage) message); if (null == msg) &#123; return Mono.empty(); &#125; return Mono.just(SimpleMqttMessage.builder() .topic(msg.getTopic()) .payload(Unpooled.wrappedBuffer(JSON.toJSONBytes(msg.getMessage()))) .build()); &#125; return Mono.empty(); &#125;); &#125; 打成jar包上传到平台","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"http://liujun1997.github.io/tags/IOT/"}]},{"title":"cdh安装部署","slug":"cdh安装部署","date":"2021-08-06T15:27:54.000Z","updated":"2021-08-06T16:24:19.253Z","comments":true,"path":"2021/08/06/cdh安装部署/","link":"","permalink":"http://liujun1997.github.io/2021/08/06/cdh%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/","excerpt":"","text":"CDH6.3.2 安装[toc] 1.安装说明1.安全前置准备，包括安装操作系统、关闭防火墙、同步服务器时钟等 2.外部数据库如MySQL安装 3.安装Cloudera Manager 4.安装CDH集群 请务必注意CDH6的安装前置条件包括如下： 外部数据库支持： MySQL 5.7或更高 MariaDB 5.5或更高 PostgreSQL 8.4或更高 Oracle 12c或更高 java环境： Oracle JDK1.8，将不再支持JDK1.7 操作系统支持 RHEL 6.8或更高 RHEL 7.2或更高 SLES 12 SP2或更高 Ubuntu 16或更高 2.集成环境2.1操作脚本 创建shell目录 mkdir -p /opt/shell/ 创建node.list文件 1touch node.list 添加如下内容： 123456master01.health.bigdata.commaster02.health.bigdata.comslave01.health.bigdata.comslave02.health.bigdata.comslave03.health.bigdata.comslave04.health.bigdata.com 创建ssh_no_passwd.sh文件 1touch ssh_no_passwd.sh 添加内容如下： 12345678910111213141516171819202122232425#!/bin/baships_name=$1#获取当前目录的绝对路径path_dir=`pwd`#找到ips文件的位置,并查看里面的内容 赋给ips_arrremote_hosts=`cat $&#123;path_dir&#125;/$&#123;ips_name&#125;`if [ -f &quot;/root/.ssh/id_rsa.pub&quot; ]|| [ -f &quot;/root/.ssh/id_rsa&quot;];then echo &quot;文件已经存在&quot;else echo &quot;文件不存在准备创建&quot; echo &quot;准备创建公钥文件&quot; ssh-keygen -t rsa -q -f &quot;/root/.ssh/id_rsa&quot; -P &#x27;&#x27;fiecho &quot;公钥创建完成&quot;echo &quot;传送至远端主机&quot;echo &quot;一共有$#台主机需要配置&quot;if [ ! -z $# ];then for host in $remote_hosts do ssh-copy-id -i /root/.ssh/id_rsa.pub $host doneelse echo &quot;请至少输入一台服务器地址&quot;fi 创建ssh_do_all.sh文件 1touch ssh_do_all.sh 添加内容如下： 1234567891011121314151617181920212223242526272829#! /bin/bash#拿到外面传进来的命令ips_name=$1cmd=&quot;&quot;for((i=2;i&lt;=$#;i++)); do j=$&#123;!i&#125; cmd=&quot;$&#123;cmd&#125; $j &quot;doneecho &quot;&#x27;$&#123;cmd&#125;&#x27;&quot;#进入到当前脚本所在的路径cd `dirname $0`#获取当前目录的绝对路径path_dir=`pwd`#找到ips文件的位置,并查看里面的内容 赋给ips_arrips_arr=`cat $&#123;path_dir&#125;/$&#123;ips_name&#125;`for ip in $&#123;ips_arr[*]&#125;do #拼接ssh命令:ssh用户名@主机名 命令 cmd_=&quot;ssh $ip &#x27;$cmd&#x27;&quot; echo $cmd_ #通过eval 实现动态执行命令 if eval $cmd_; then echo &#x27;ok&#x27; else echo &#x27;fail&#x27; fidone 执行命令: 1sh ssh_do_all.sh node.list df -h 创建scp_do_all.sh文件 1touch scp_do_all.sh 添加内容如下: 1#! /bin/bash#脚本使用说明# ./scp_do_all.sh f1 /home/luser/dirips_name=$1#你要传的文件source_=$2#目标目录target=$3#先进入当前脚本的所在路径cd `dirname $0`#获取当前目录的绝对路径path_dir=`pwd`#找到ips文件的位置，并查看里面的内容 赋给 ips_arrips_arr=(`cat $&#123;path_dir&#125;/$&#123;ips_name&#125;`)for ip in $&#123;ips_arr[*]&#125;do #拼接scp 命令： scp 你要传的文件 用户名@主机名:目标目录 cmd_=&quot;scp $source_ $ip:$target&quot; echo $cmd_ #通过eval 实现动态执行命令 if eval $cmd_ ; then echo &#x27;ok&#x27; else echo &#x27;fail&#x27; fidone 执行命令: 1sh scp_do_all.sh node.list /etc/hosts /etc/ 2.2hostname修改各节点的hostname配置 1vi /etc/hostname#hostnameip-172-31-13-38.ap-southeast-1.compute.internal 或者你可以通过命令修改立即生效 hostnamectl set-hostname ip-172-31-13-38.ap-southeast-1.compute.internal 2.3hosts配置1vi /etc/hosts 1[root@gxwj-zhongjj-8 ~]# cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain619.50.65.66 master01.health.bigdata.com19.50.65.67 master02.health.bigdata.com19.50.65.68 slave01.health.bigdata.com19.50.65.71 slave02.health.bigdata.com19.50.65.75 slave03.health.bigdata.com19.50.65.76 slave04.health.bigdata.com 将文件复制的集群的各个节点 2.4SSH免登陆 在主节点执行sh脚本 执行命令 1ssh ssh_no_passwd.sh node.list 2.5配置iso镜像源创建iso目录 1mkdir /opt/iso 创建http目录 1sudo mkdir /var/www/html/iso 将ISO镜像文件移到/opt/iso目录 1cp CentOS-7-x86_64-DVD-1908.iso /opt/iso 临时挂载，重启无效 1sudo mount -o loop /opt/iso/CentOS-7-x86_64-DVD-1908.iso /var/www/html/iso 通过 df -h命令查看 永久挂载操作系统iso文件 注意格式，容易出错，内容tab键隔开 1vi /etc/fstab 最末端添加内容 1/opt/iso/CentOS-7-x86_64-DVD-1908.iso /var/www/html/iso/ iso9660 defaults,ro,loop 0 0 执行重新加载命令 1mount -a 内容格式不对，会出错，如下： 显示/etc/fstab的内容 1mount 查看是否挂载成功 注意：如果不成功，需要修改配置内容与格式，否则系统重启无法进入用户会话 1df -h 配置操作系统repo 创建os.repo文件 1sudo vim /etc/yum.repos.d/os.repo 本地os.repo配置内容 1[local_iso]name=CentOS-$releasever - Mediabaseurl=file:///var///www///html///isogpgcheck=0enabled=1 同时按照httpd服务 yum install httpd 其他服务器节点os.repo配置内容 1[osrepo]#自定义名称name=os_repo#yum访问路径baseurl=http://19.50.65.66/iso/#启用yum源，0为不启用，1为启用enabled=1#检查GPG-KEY，0为不检查，1为检查gpgcheck=0 删除所有默认的repo所有节点都是 1/etc/yum.repo.d/ 查看当前可用的源 1sudo yum repolist 清除缓存 1yum clean all 2.6集群时钟同步参考网上ntp安装教程 批量添加定时同步时间 1vi ntpCrontab.sh 内容如下： 1#!/bin/baships_name=$1#获取当前目录的绝对路径path_dir=`pwd`#找到ips文件的位置,并查看里面的内容 赋给ips_arrremote_hosts=`cat $&#123;path_dir&#125;/$&#123;ips_name&#125;`for i in cat $remote_hostsdo echo $i ssh $i &quot;(echo &#x27;0 */10 * * * /usr/sbin/ntpdate -u 19.50.65.66&#x27; ;crontab -l) |crontab&quot; echo &quot;Synchronization is complete.&quot;done 或者(推荐) ntpdate.sh 1#!/usr/bin/env bashcd /opt/shellsh ssh_do_all.sh ipa.list ntpdate -u cdhclient sudo vi /etc/crontab 1SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed#添加内容*/5 * * * * root /opt/shell/ntpdate.sh &gt;&gt; /opt/shell/ntpdate.log 重启cron定时服务 1systemctl status crond 1systemctl restart crond 2.7ansible安装安装依赖 1yum install -y ansible 配置/etc/ansible/hosts 1##补充内容# This is the default ansible &#x27;hosts&#x27; file.## It should live in /etc/ansible/hosts## - Comments begin with the &#x27;#&#x27; character# - Blank lines are ignored# - Groups of hosts are delimited by [header] elements# - You can enter hostnames or ip addresses# - A hostname/ip can be a member of multiple groups# Ex 1: Ungrouped hosts, specify before any group headers.## green.example.com## blue.example.com## 192.168.100.1## 192.168.100.10# Ex 2: A collection of hosts belonging to the &#x27;webservers&#x27; group## [webservers]## alpha.example.org## beta.example.org## 192.168.1.100## 192.168.1.110# If you have multiple hosts following a pattern you can specify# them like this:## www[001:006].example.com# Ex 3: A collection of database servers in the &#x27;dbservers&#x27; group## [dbservers]#### db01.intranet.mydomain.net## db02.intranet.mydomain.net## 10.25.1.56## 10.25.1.57# Here&#x27;s another example of host ranges, this time there are no# leading 0s:## db-[99:101]-node.example.com[all]cdhmaster1.chiefdata.netcdhnode1.chiefdata.netcdhnode2.chiefdata.netcdhnode3.chiefdata.netcdhnode4.chiefdata.netcdhclient.chiefdata.net[ntp]cdhmaster1.chiefdata.netcdhnode1.chiefdata.netcdhnode2.chiefdata.netcdhnode3.chiefdata.netcdhnode4.chiefdata.net[ipa]cdhmaster1.chiefdata.netcdhnode1.chiefdata.netcdhnode2.chiefdata.netcdhnode3.chiefdata.netcdhnode4.chiefdata.net 执行批量操作命令 批量执行命令： 1ansible all -m command -a &quot;df -h&quot; all 是分组命令 批量执行shell文件： 1ansible all -m script -a ./check_env.sh 2.7初始化配置创建check_env.sh文件 1touch check_env.sh 增加文件内容： 1vi check_env.sh 内容如下： 1#!/bin/bash# 系统时间datetime=`date &quot;+%Y%m%d%H%M%S&quot;`# 关闭 firewalldsystemctl stop firewalldsystemctl disable firewalld#关闭 selinuxcp /etc/selinux/config /tmp/selinux_config.&quot;$datetime&quot;setenforce 0SELINUX=`grep &#x27;SELINUX=&#x27; /etc/selinux/config|grep -v &quot;^#&quot;|awk -F&quot;=&quot; &#x27;&#123;print $2&#125;&#x27;`if [ &quot;$SELINUX&quot; == &quot;enforcing&quot; ];then sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/configelif [ &quot;$SELINUX&quot; == &quot;permissive&quot; ];then sed -i &#x27;s/SELINUX=permissive/SELINUX=disabled/g&#x27; /etc/selinux/configelse echo &quot;have already been disabled,Don&#x27;t need to modify&quot;fi# 关闭 tunedtuned-adm offtuned=`systemctl status tuned|grep &#x27;Active: active (running)&#x27;|wc -l`if [ $tuned == 1 ];then systemctl stop tuned echo &#x27;tuned stop successful&#x27;else echo &#x27;tuned already stopped&#x27;fisystemctl disable tuned# 设置 vm.swappinesscp /etc/sysctl.conf /tmp/etc_sysctl.&quot;$datetime&quot;sysctl -w vm.swappiness=1swappiness=`grep &quot;vm.swappiness=&quot; /etc/sysctl.conf|awk -F &quot;=&quot; &#x27;&#123;print $2&#125;&#x27;`if [ &quot;$swappiness&quot; -gt 1 ];then sed -i &#x27;s/vm.swappiness=&#x27;$swappiness&#x27;/vm.swappiness=1/g&#x27; /etc/sysctl.confelif [ ! -n &quot;$swappiness&quot; ];then echo &quot;vm.swappiness=1&quot; &gt;&gt; /etc/sysctl.confelse echo &quot;swappiness=1,Don&#x27;t need to modify&quot;fi# 设置 THPcp /sys/kernel/mm/transparent_hugepage/enabled /tmp/THP_enabled.&quot;$datetime&quot;cp /sys/kernel/mm/transparent_hugepage/defrag /tmp/THP_defrag.&quot;$datetime&quot;cp /etc/rc.d/rc.local /tmp/rc.local.&quot;$datetime&quot;echo &quot;never&quot; &gt; /sys/kernel/mm/transparent_hugepage/enabledecho &quot;never&quot; &gt; /sys/kernel/mm/transparent_hugepage/defragthp_enabled=`grep &quot;transparent_hugepage&quot; /etc/rc.d/rc.local|grep &quot;enabled&quot;`thp_defrag=`grep &quot;transparent_hugepage&quot; /etc/rc.d/rc.local|grep &quot;defrag&quot;`if [ ! -n &quot;$thp_enabled&quot; ];then echo &#x27;echo &quot;never&quot; &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; &gt;&gt; /etc/rc.d/rc.localfiif [ ! -n &quot;$thp_defrag&quot; ];then echo &#x27;echo &quot;never&quot; &gt; /sys/kernel/mm/transparent_hugepage/defrag&#x27; &gt;&gt; /etc/rc.d/rc.localfichmod +x /etc/rc.d/rc.local 执行批量操作命令 批量执行shell文件： 注意：all 是分组，对应配置/etc/ansible/hosts配置里面的[all]内容 1ansible all -m script -a ./check_env.sh 2.8安装mariadb数据库1.安装MariaDB 1[root@ip-172-31-13-38 ~]# yum -y install mariadb[root@ip-172-31-13-38 ~]# pyyum -y install mariadb-server 2.启动并配置MariaDB 1[root@ip-172-31-13-38 ~]# systemctl start mariadb[root@ip-172-31-13-38 ~]# systemctl enable mariadbCreated symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.[root@ip-172-31-13-38 ~]# /usr/bin/mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&#x27;ll need the currentpassword for the root user. If you&#x27;ve just installed MariaDB, andyou haven&#x27;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): 输入密码OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] YNew password:Re-enter new password:Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] Y ... Success!Normally, root should only be allowed to connect from &#x27;localhost&#x27;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] n ... skipping.By default, MariaDB comes with a database named &#x27;test&#x27; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] Y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] Y ... Success!Cleaning up...All done! If you&#x27;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB! 3.权限配置 1mysql -u root -h localhost -p 1GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;12345678&#x27; 这里的123456为你给新增权限用户设置的密码，%代表所有主机，也可以具体到你的主机ip地址 1;flush privileges; 2.9建立组件服务需要的数据表登录mysql 或者直接通过navicat 工具远程操作也可以，方便些 1mysql -u root -h localhost -p 执行脚本 1CREATE DATABASE IF NOT EXISTS hbd_manage DEFAULT CHARSET utf8 COLLATE utf8_general_ci;CREATE DATABASE IF NOT EXISTS dolphinscheduler DEFAULT CHARSET utf8 COLLATE utf8_general_ci;create database metastore default character set utf8;CREATE USER &#x27;ds&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;GRANT ALL PRIVILEGES ON dolphinscheduler . * TO &#x27;ds&#x27;@&#x27;%&#x27;;FLUSH PRIVILEGES;create database health_metastore default character set utf8;create database health_cm default character set utf8;create database health_hue default character set utf8;create database health_sentry default character set utf8;create database health_oozie default character set utf8;create database health_am default character set utf8;create database health_rm default character set utf8;create database health_nav_ms default character set utf8;create database health_nav_as default character set utf8; 2.10安装JDBC驱动上传mysql-connector-java-5.1.34.jar到服务器 创建软连接 所有节点都需要做统一操作 1mkdir -p /usr/share/java/cp mysql-connector-java-5.1.34.jar /usr/share/java/chmod 777 /usr/share/java/mysql-connector-java-5.1.34.jarln -s /usr/share/java/mysql-connector-java-5.1.34.jar /usr/share/java/mysql-connector-java.jar 或者直接改名 mysql-connector-java.jar 3.CM安装3.1配置cm repo源把cm6.3.1和cdh6.3.2文件夹拷贝到httpd服务器上 注意：这里的服务器是FreeIPA的服务端，因为FreeIPA的服务端已经安装了httpd 上传至：**/var/www/html** 目录 创建repo 安装create repo 1yum install createrepo 在cm6.3.1文件夹里面执行，cdh6.3.2不需要此操作 1createrepo . 制作cm的repo源 创建cm.repo文件 1sudo vim /etc/yum.repos.d/cm.repo cm.repo配置内容 1[cm_repo]name = cm_repobaseurl = http://19.50.65.66/cm6.3.1enabled = 1gpgcheck = 0 把cm.repo 上传到其他节点服务器 1sh scp_do_all.sh node.list /etc/yum.repos.d/cm.repo /etc/yum.repos.d/ 查看当前可用的源 1sudo yum repolist 清除缓存 1yum clean all 3.2安装JDK批量安装命令，安装cm自带的jdk 1sh ssh_do_all.sh node.list yum -y install oracle-j2sdk1.8-1.8.0+update181-1.x86_64 Jdk环境变量配置 执行命令 1vim /etc/profile 配置内容 1export JAVA_HOME=/usr/java/jdk1.8.0_181-clouderaexport CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 复制到其他服务节点 1sh scp_do_all.sh node.list /etc/profile /etc/ 重新加载 1source /etc/profilesh ssh_do_all.sh node.list source /etc/profile 卸载旧版jdk 确定JDK的版本 1rpm -qa | grep jdkrpm -qa | grep gcj 查看的结果是： 1libgcj-4.1.2-42.el5 java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 java-1.8.0-openjdk-headless-1.8.0.242.b08-0.el7_7.x86_64 2.然后卸载： 1yum -y remove java-1.8.0-openjdk-headless-1.8.0.242.b08-0.el7_7.x86_64 1sh ssh_do_all.sh node.list yum -y remove java-1.8.0-openjdk-headless-1.8.0.242.b08-0.el7_7.x86_64 如果这种方法不行，可以使用如下的方法卸载： 11）卸载系统自带的jdk版本： 查看自带的jdk： #rpm -qa|grep gcj 可能看到如下类似的信息： libgcj-4.1.2-44.el5 java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 使用rpm -e --nodeps 命令删除上面查找的内容： #rpm -e –nodeps java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 2）卸载rpm安装的jkd版本 查看安装的jdk： #rpm -qa|grep jdk 可能看到如下类似的信息： jdk-1.6.0_22-fcs 卸载： #rpm -e --nodeps jdk-1.6.0_22-fcs 3）找到jdk安装目录的_uninst子目录·在shell终端执行命令./uninstall.sh即可卸载jdk 3.2安装Cloudera Manager3.3.1Cloudera Manager Server安装通过yum安装Cloudera Manager Server 1yum -y install cloudera-manager-server 初始化数据库 1/opt/cloudera/cm/schema/scm_prepare_database.sh -h192.168.18.188 --scm-host 192.168.18.188 mysql cdh_cm root 12345678 启动CM server 1systemctl start cloudera-scm-serversystemctl status cloudera-scm-serversystemctl stop cloudera-scm-server#开机启动systemctl enable cloudera-scm-server 3.3.2Cloudera Manager Agent安装注意：此步骤可以忽略，让cm管理平台自动安装，所有节点都要安装 通过yum安装Cloudera Manager Agent 1yum -y install cloudera-manager-agent 启动CM agent 1systemctl start cloudera-scm-agentsystemctl status cloudera-scm-agentsystemctl stop cloudera-scm-agent#开机启动systemctl enable cloudera-scm-agent 3.4CDH安装3.4.1CDH集群安装向导 admin/admin登录到CM 同意license协议，点击继续 选择60试用，点击继续 或者直接选择免费开源版 点击“继续”systemctl restart cloudera-scm-agent 点击“继续”，输入集群名称，可以使用默认的“Cluster 1”。 输入主机IP或者名称，点击搜索找到主机后点击继续 选择自定义存储库，输入cm的http地址 ​ “CDH and other software”中选择“使用 Parcel (建议)”，点击“ 更多选项”，点击“-”删除其它所有地址，输入http://172.31.13.38/cdh6.3，点击“保存更改” 点击“继续”，进入下一步安装jdk 点击“继续”，进入下一步配置ssh账号密码 相同密码： 公钥： 把主节点的私钥上传到上面 点击“继续”，进入下一步，安装Cloudera Manager相关到各个节点 等待Agent安装完毕后，自动跳转到下一步开始分发Parcel 点击“继续”，进入下一步安装cdh到各个节点 点击Inspect Network Performance和Inspect Hosts，检查主机 如果有错误或者黄色警告，查看“显示检查器结果”，并逐项解决，然后“重新运行”检查，直到所有的检查都通过，否则没办法点击继续下一步。 3.4.2集群设置安装向导 选择需要安装的服务，根据需要选择，这里随便选择Data Warehouse，也可以自定义服务 点击“继续”，进入集群角色分配，一台机器作为管理节点，另外三台机器作为DataNode 注意：Activity Monitor和Telemetry Publisher不用选择任何主机，留空，即不安装，因为用不到。 点击“继续”，进入下一步，测试数据库连接 测试成功，点击“继续”，进入目录设置，此处使用默认默认目录，根据实际情况进行目录修改 点击“继续”，进入各个服务启动 安装成功后进入home管理界面 3.4.3组件版本检查 可以看到Hadoop3.0，Flume1.9，HBase2.1，Hive2.1.1，Spark2.4，Hue4.2.0，Impala3.2，Kafka2.2.1，Kudu1.0，Oozie5.1，Pig0.17，Senty2.1，Solr7.4，Sqoop1.4.7，Zookeeper3.4.5等。","categories":[],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://liujun1997.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://liujun1997.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://liujun1997.github.io/tags/Linux/"},{"name":"Java","slug":"Java","permalink":"http://liujun1997.github.io/tags/Java/"},{"name":"IOT","slug":"IOT","permalink":"http://liujun1997.github.io/tags/IOT/"},{"name":"大数据","slug":"大数据","permalink":"http://liujun1997.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]}